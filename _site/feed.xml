<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-Hans"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-Hans" /><updated>2021-12-09T13:33:58+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wenxing Lai</title><subtitle>Wenxing’s blog is right here.
</subtitle><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><entry><title type="html">深入Go：Context</title><link href="http://localhost:4000/2021/12/06/%E6%B7%B1%E5%85%A5Go-Context.html" rel="alternate" type="text/html" title="深入Go：Context" /><published>2021-12-06T00:00:00+00:00</published><updated>2021-12-06T00:00:00+00:00</updated><id>http://localhost:4000/2021/12/06/%E6%B7%B1%E5%85%A5Go:Context</id><content type="html" xml:base="http://localhost:4000/2021/12/06/%E6%B7%B1%E5%85%A5Go-Context.html">&lt;p&gt;在之前的文章中我们了解了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;的使用，我们很自然地会提出一些问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;被传递到多个goroutine中，如何保证没有data race？&lt;/li&gt;
  &lt;li&gt;有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CancelFunc&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;，如果不被取消，会有怎样的风险？&lt;/li&gt;
  &lt;li&gt;父&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;被取消，如何自动地使得所有子节点被取消？&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt;如果多次被同一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;写入值，结果会是怎样？&lt;/li&gt;
  &lt;li&gt;听说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;以链表的形式存储Value，会不会有性能问题？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;带着这些问题，我们一同进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;包，看看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;的设计有着怎样的精妙之处与潜在的坑。&lt;/p&gt;

&lt;p&gt;我们这里略过包的注释、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Canceled, DeadlineExceeded error&lt;/code&gt;以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;的定义（可以参见上一篇文章），直接从“原初”的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;emptyCtx&lt;/code&gt;开始。&lt;/p&gt;

&lt;p&gt;注意，从下文开始，我们会在源码中加入形如⑴、⑵或㊟的记号，表示后续会进行详细阐释；如未特殊说明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//&lt;/code&gt;开头的注释为源码注释的翻译，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/* */&lt;/code&gt;包围的注释为笔者所加评注。&lt;/p&gt;

&lt;h2 id=&quot;源码与解析&quot;&gt;源码与解析&lt;/h2&gt;

&lt;p&gt;源码来自go 1.17.3。&lt;/p&gt;

&lt;h3 id=&quot;emptyctx-background与todo&quot;&gt;emptyCtx, Background()与TODO()&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 一个emptyCtx不能被取消、没有Values或deadline。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 它不是struct{}类型因为每个emptyCtx实例都需要不同的地址㊟。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 见下方 var background 和 todo */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;context.Background&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;context.TODO&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;unknown empty Context&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;background&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emptyCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/* 即，emptyCtx的实例有且仅有这里的 backgroud 与 todo */&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Background 返回非nil的空Context。它不能被取消、没有Values或deadline。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 它被用于main函数、初始化、测试与顶层的请求。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;background&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// TODO 返回非nil的空Context。当不确定应该使用哪一个Context或Context暂时不可用&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// （因该处的函数还没有被扩展以接收Context参数）时，代码应使用context.TODO。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TODO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;todo&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-为什么不使用-struct&quot;&gt;㊟ 为什么不使用 struct{}？&lt;/h4&gt;

&lt;p&gt;请看下方代码片段：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%p, %p, %t&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请问输出应该是什么？答案是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
0x119e408, 0x119e408, true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go run -gcflags &apos;-m&apos; main.go&lt;/code&gt;运行，可以发现：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./main.go:19:2: moved to heap: s1
./main.go:19:6: moved to heap: s2
./main.go:20:43: &amp;amp;s1 == &amp;amp;s2 escapes to heap
./main.go:20:12: []interface {} literal does not escape
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct{}&lt;/code&gt;的实例逃逸到heap上，那它们的地址可能相同。事实上，&lt;a href=&quot;https://go.dev/ref/spec#Size_and_alignment_guarantees&quot;&gt;The Go Programming Language Specification: Size and alignment guarantees&lt;/a&gt;确认了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.&lt;/p&gt;

  &lt;p&gt;struct或者array如果其不包含size大于0的字段，则其size为0。两个不同的size为0的变量可能拥有同一个地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;emptyCtx&lt;/code&gt;类型不使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;struct{}&lt;/code&gt;，为了确保&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;todo&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;background&lt;/code&gt;拥有不同的地址。&lt;/p&gt;

&lt;h3 id=&quot;withcancel与concelfunc&quot;&gt;WithCancel与ConcelFunc&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 一个CancelFunc告知相关操作应被取消。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 一个CancelFunc并不等待操作结束。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 一个CancelFunc可以被多个goroutine并发调用。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 第一次调用后，对CancelFunc的随后调用无实际效果。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// WithCancel 返回parent的一个拷贝以及一个新的Done channel。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 在返回的cancel函数被调用时，或其父context的Done channel被关闭时，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 返回的context的Done channel被关闭。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 取消该context将释放相关的资源⑴，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 因此代码应该在本Context相关的操作结束时立即调用cancel。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cannot create context from nil parent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newCancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;propagateCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Canceled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// newCancelCtx 返回初始化后的cancelCtx实例。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newCancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// goroutines ...; 测试用。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goroutines&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// propagateCancel 使得parent被cancel时，cancel掉child。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;propagateCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canceler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// parent不能被cancel&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 此时parent已经被cancel&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/* parentCancelCtx 尝试返回parent的cancelCtx指针 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentCancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// parent 已经被cancel&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canceler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 例外，此时只能新启动协程监听parent.Done */&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;/* 例如parent恰好被cancel，或parent为非cancelCtx结构(没法通过children来cancel) */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddInt32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;goroutines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// &amp;amp;cancelCtxKey 为cancelCtx返回其自身的指针值的key。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelCtxKey&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// parentCancelCtx 返回承载parent的*cancelCtx。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 本函数通过查parent.Value(&amp;amp;cancelCtxKey)来找到最里层的*cancelCtx，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 并检查parent.Done()是否匹配该*cancelCtx。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// （如果不匹配，则该*cancelCtx已被嵌入非默认的、提供不同done channel的实现中，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 此时我们不应绕过该它⑵。）&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentCancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closedchan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtxKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pdone&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdone&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// removeChild 从parent处移除该context。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canceler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentCancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 一个canceler为可以被直接cancel的context类型。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 实现包括：*cancelCtx和*timerCtx。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canceler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeFromParent&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// closedchan 为用于复用的、代表已关闭的channel⑶。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/* 在init中确保closedchan被关闭 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closedchan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closedchan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// cancelCtx实例可以被cancel。当其被cancel，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 该实例也将cancel其所有实现了canceler的子节点&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 此即parent Context */&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// mu用于保护下列字段&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// 延迟创建的done用于存储chan struct{}&lt;/span&gt;
                                  &lt;span class=&quot;c&quot;&gt;// 并在第一次cancel时被关闭&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canceler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 第一次cancel将该字段设为nil&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;// 第一次cancel将该字段设为非nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtxKey&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 在parent的Value中查找 */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stringer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reflectlite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.WithCancel&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// cancel 关闭c.done、cancel所有c的子Context，且如果&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// removeFromParent为true，则将其从parent的children中移除&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeFromParent&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;context: internal error: missing cancel error&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 已经被cancel过&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// done还没被使用chan struct{}创建&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closedchan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 注意：此时持有parent的锁，并申请child的锁&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeFromParent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;removeChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-完成后立即cancel&quot;&gt;⑴ 完成后立即cancel&lt;/h4&gt;

&lt;p&gt;源码的注释或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go vet&lt;/code&gt;都要求我们在操作完成后立即调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel&lt;/code&gt;保证资源及时释放，例如通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defer cancel()&lt;/code&gt;的方式。那么对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx&lt;/code&gt;，及时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel&lt;/code&gt;释放了什么资源？&lt;/p&gt;

&lt;p&gt;一是我们留意到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;propagateCancel&lt;/code&gt;这里有如下函数：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即某种情况下，可能需要新增协程来监听parent或自身的done channel，如果及时cancel则该协程会及时退出。（至于什么时候会新增协程来监听，见注释⑵。）&lt;/p&gt;

&lt;p&gt;第二点，显然cancel可以使得本context从parent.children中移除；并且，这是在parent不被cancel的情况下，唯一释放该child的方法。经测试，parent为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*cancelCtx&lt;/code&gt;，以此调用1000000次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithCancel&lt;/code&gt;然后直接返回，系统内存占用为205MB，如果child都立即被cancel，则系统内存占用为70MB。&lt;/p&gt;

&lt;p&gt;三也很显然，cancel该Context后，所有子节点都会被cancel掉，从而可以使得更多地资源被及时回收。&lt;/p&gt;

&lt;h4 id=&quot;-parentcancelctx&quot;&gt;⑵ parentCancelCtx&lt;/h4&gt;

&lt;p&gt;为什么通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p, ok := parent.Value(&amp;amp;cancelCtxKey).(*cancelCtx)&lt;/code&gt;找到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*cancelCtx&lt;/code&gt;（即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ok == true&lt;/code&gt;）之后，还需要确保&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pDone == p&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;看如下代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CustomContext&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里，如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CustomContext.Context&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*cancelCtx&lt;/code&gt;，且被传入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.WithCancel&lt;/code&gt;，那么在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parentCancelCtx&lt;/code&gt;中会找到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CustomContext.Context&lt;/code&gt;，但这里如果直接返回，就返回的是祖父节点的的指针。&lt;/p&gt;

&lt;p&gt;我们也可以用如下代码验证：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumGoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumGoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithCancel&lt;/code&gt;的操作，新增了一个goroutine用于监听&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c.Done()&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;-closedchan&quot;&gt;⑶ closedchan&lt;/h4&gt;

&lt;p&gt;为什么需要全局变量（且专门在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;中close掉的）&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closedchan&lt;/code&gt;？&lt;/p&gt;

&lt;p&gt;这是因为，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt;的注释说明了该&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chan struct{}&lt;/code&gt;是延迟创建的，且正好是被调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;时创建，如果一个Context尚未被调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;就被cancel了，那么如果没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closedchan&lt;/code&gt;则需要新创建一个channel并立即close掉。&lt;/p&gt;

&lt;h3 id=&quot;withdeadline与withtimeout&quot;&gt;WithDeadline与WithTimeout&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// WithDeadline 返回附有截止时间不晚于d的parent的拷贝。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 如果parent的deadline早于d，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// WithDeadline(parent, d)语义上与parent相同。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 返回的Context的Done channel将被关闭，当下列任一情况满足：&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 到达截止时间，或&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 返回的cancel函数被调用，或&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// parent的Done channel被关闭。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 取消该context将释放相关的资源㊟，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 因此代码应该在本Context相关的操作结束时立即调用cancel。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithDeadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cannot create context from nil parent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Before&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 已有的截止时间早于参数d&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newCancelCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;propagateCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dur&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeadlineExceeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 截止时间已超过&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Canceled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 此时返回的c已被cancel */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 因为可能此时parent被cancel，所以需要用c.mu保护 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 也是防止在获取锁之前因parent而被cancel */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AfterFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DeadlineExceeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Canceled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// timerCtx实例包含一个计时器与截止时间。它嵌入了一个cancelCtx来实现Done与Err。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 它通过停止其计时器并使用cancelCtx.cancel来实现cancel。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timerCtx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Timer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 受cancelCtx.mu保护。&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.WithDeadline(&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; [&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;])&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timerCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;removeFromParent&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;removeFromParent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 从parent处移除c&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;removeChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelCtx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;/* 真正的parent是c.cancelCtx.Context */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// WithTimeout 返回WithDeadline(parent, time.Now().Add(timeout))。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 取消该context将释放相关的资源，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 因此代码应该在本Context相关的操作结束时立即调用cancel：&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//     func slowOperationWithTimeout(ctx context.Context) (Result, error) {&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//         ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//         defer cancel()  // 如果slowOperation在超时之前就完成了，则释放资源&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//         return slowOperation(ctx)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//     }&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancelFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithDeadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-完成后立即cancel-1&quot;&gt;㊟ 完成后立即cancel&lt;/h4&gt;

&lt;p&gt;这里需要及时cancel的原因与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx&lt;/code&gt;类似，只不过有timer兜底，不会“永远地”内存泄漏。&lt;/p&gt;

&lt;h3 id=&quot;withvalue&quot;&gt;WithValue&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// WithValue 返回parent的拷贝，并附上key对应的值val。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 仅对不同进程与API间转移的请求范畴内的数据使用context的Value，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 而不是用以传递函数的可选参数。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 提供的key必须是可比较的类型，且为避免在各使用context的包内冲突，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 它不应是字符串或任意内置类型。使用WithValue的用户应自定义key的类型。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 为避免赋值给interface{}时的内存分配，context key通常使用类型struct{}。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 另外，导出的context key变量的静态类型应该为pointer或interface。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cannot create context from nil parent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nil key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reflectlite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key is not comparable&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// valueCtx实例携带key-value pair。它对该key实现了Value函数，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 并使用嵌入的Context来应对其余函数调用。&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;It&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// delegates all other calls to the embedded Context.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueCtx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// stringify 尝试在不使用fmt的情况下将v转换为字符串，这是因为&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// context并不希望依赖unicode表。本函数仅在*valueCtx.String()中使用。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;not Stringer&amp;gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contextName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.WithValue(type &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reflectlite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;, val &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;)&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/* Value 以类似链表的形式实现，我们在稍后会讨论到 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueCtx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;对context的批评并尝试回应&quot;&gt;对Context的批评（并尝试回应）&lt;/h2&gt;

&lt;h3 id=&quot;批评&quot;&gt;批评&lt;/h3&gt;

&lt;p&gt;Michal Štrba在文章&lt;em&gt;&lt;a href=&quot;https://faiface.github.io/post/context-should-go-away-go2/&quot;&gt;Context should go away for Go 2&lt;/a&gt;&lt;/em&gt;中批评了Context的设计，甚至说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx.Value&lt;/code&gt; in my (non-existent) company, you’re fired.&lt;/p&gt;

  &lt;p&gt;如果你在我（并不存在的）公司中使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx.Value&lt;/code&gt;，你将被开除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TA的指责主要可以总结为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从请求生命周期开始到结束的每一个函数，即使有的并不需要使用到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx&lt;/code&gt;，也被迫需要将其作为第一个参数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Context is like a virus.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.Value&lt;/code&gt;问题重重：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;并非静态类型安全，需要类型断言。&lt;/li&gt;
      &lt;li&gt;存储的内容并非静态可感知。&lt;/li&gt;
      &lt;li&gt;可能命名冲突造成问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用类似于链表的结构，存在性能问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx context.Context&lt;/code&gt;看起来就很啰嗦（然后TA顺便黑了一下Java：让人想起&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo foo = new Foo();&lt;/code&gt;）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里，我们尝试对Michal Štrba的观点作一个回应。&lt;/p&gt;

&lt;h3 id=&quot;回应&quot;&gt;回应&lt;/h3&gt;

&lt;h4 id=&quot;cxt污染&quot;&gt;cxt污染&lt;/h4&gt;

&lt;p&gt;Context本来就是用于控制请求的生命周期的，所以很自然地从始至终需要传递；退一步讲，如果换其他实现，想达到能控制整个请求生命周期的目的，也需要始终传递某个参数——不然怎么能实现“控制整个请求生命周期”？&lt;/p&gt;

&lt;p&gt;以及，并不是所有核请求相关的函数都需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx&lt;/code&gt;参数，那些与API调用无关的过程自然也就不需要该参数——该参数仅存在于请求的“主干”上。Michal Štrba其实误解了Context的用法。&lt;/p&gt;

&lt;h4 id=&quot;value的问题&quot;&gt;Value的问题&lt;/h4&gt;

&lt;p&gt;的确，没有固定类型的Value是代价，但换取的是灵活性。我们总能想起来“但是，古尔丹，代价是什么呢”，那么我们也应该想到，“但是，gopher，代价带来的是什么呢”。&lt;/p&gt;

&lt;p&gt;我们考虑以下两点，其实可以或多或少地排除掉这个顾虑：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;正如源码文档所写，应该使用存取函数来完成值的读写，而不是直接操纵&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctx.Value&lt;/code&gt;本身；并且，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;都使用非导出的包作用域的变量，自然不会存在冲突的问题；&lt;/li&gt;
  &lt;li&gt;在此前的文章&lt;em&gt;&lt;a href=&quot;https://km.woa.com/articles/view/529748&quot;&gt;The Context of the Package context&lt;/a&gt;&lt;/em&gt;中，我们非常认可Jack Lindamood在Gophercon UK 2017所述：&lt;em&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context.Value&lt;/code&gt; should inform, not control&lt;/em&gt;；真正必不可少的“参数”，应该是通过函数参数来传递，而不是Context——这也在源码文档里有专门提到。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;性能问题&quot;&gt;性能问题&lt;/h4&gt;

&lt;p&gt;首先回应Michal Štrba指责的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx&lt;/code&gt;有时需要goroutine来通知，但通常我们不会去重定义Context的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;返回的channel，实际上你是否能想到非得重定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;的行为的必要场景？&lt;/p&gt;

&lt;p&gt;其次是，Context之间的内嵌使得节点关系是近似于链表的结构，而不是更高效的数据结构。比如很容易想到的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithValue&lt;/code&gt;竟然是通过新增Context节点来完成的。&lt;/p&gt;

&lt;p&gt;那这个代价换来了什么？换来的是严格意义上的父子节点的关系。或者思考，如何实现一个仅能访问自身节点与祖先节点所存储的数据的结构？&lt;/p&gt;

&lt;p&gt;并且我们退一步讲，代价究竟有多大。首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithValue&lt;/code&gt;并不是一个应该被频繁调用的函数，这点我们不再赘述，所以用于存储Value的这部分链表的长度其实是有限的；其次是，对于cancel被传递下去的代价是什么，其实回顾&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timerCtx&lt;/code&gt;的代码，可以发现里面的操作都是必须的，并没有什么冗余，且基本没有需要等待channel的情况（如果不考虑重新定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;返回的channel这一情况）。&lt;/p&gt;

&lt;p&gt;实际上，我们测试了，通过连续调用1000次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithCancel&lt;/code&gt;，然后第一个Context的cancel被调用，第1000个Context平均在0.10ms后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done()&lt;/code&gt;接收到结果。要留意到，Context是用来控制耗时以毫秒为单位的请求的，似乎看起来Context本身的开销其实微乎其微。&lt;/p&gt;

&lt;h4 id=&quot;啰嗦&quot;&gt;啰嗦&lt;/h4&gt;

&lt;p&gt;Emmm，除非把Context设为内置类型并缩短命名，使得可以变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func (ctx Ctx)&lt;/code&gt;外，好像没啥好说的。&lt;/p&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;p&gt;我们对Context提出诘难的时候也应该思考，我们是否真正用对了Context，我们是否有更好的解决方法呢？&lt;/p&gt;

&lt;h2 id=&quot;解答提出的问题&quot;&gt;解答提出的问题&lt;/h2&gt;

&lt;h3 id=&quot;如何保证没有data-race&quot;&gt;如何保证没有data race&lt;/h3&gt;

&lt;p&gt;看了代码可以知道，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;todo&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;background&lt;/code&gt;无需保护、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx&lt;/code&gt;使用mutex和原子操作来保护&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;children&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timerCtx&lt;/code&gt;嵌入了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx&lt;/code&gt;并以其mutex保护自己的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;timer&lt;/code&gt;，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;valueCtx&lt;/code&gt;的key-value pair都是只读的，因此不用担心data race。&lt;/p&gt;

&lt;p&gt;不过这里需要注意的是，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context.Value&lt;/code&gt;不应存储并发访问不安全的数据。&lt;/p&gt;

&lt;h3 id=&quot;关于cancel&quot;&gt;关于cancel&lt;/h3&gt;

&lt;p&gt;通过代码，我们知道了cancel的传递（在非自定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done&lt;/code&gt;返回的channel的情况下）是通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancelCtx.children&lt;/code&gt;来完成的；cancelCtx的子节点不手动cancel的话，可能会使得&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent.children&lt;/code&gt;持续膨胀，导致泄露。&lt;/p&gt;

&lt;h3 id=&quot;关于重复赋值value&quot;&gt;关于重复赋值value&lt;/h3&gt;

&lt;p&gt;请不要重复赋值value。但阅读代码之后可以发现，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Value&lt;/code&gt;的调用是从子节点回溯到祖先节点，因此会找到最新的value（但并不会覆盖原有值）。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 注意，不要用内置类型作为key的类型&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bar&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;today&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// today&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// world&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;关于性能问题&quot;&gt;关于性能问题&lt;/h3&gt;

&lt;p&gt;在上一节已经探讨过了，不再赘述。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;关于Context的使用，请参加之前的文章《使用context包轻松完成并发控制》。&lt;/p&gt;

&lt;p&gt;我们以如下代码行的示意图图来作结：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;baz&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cancel3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// &amp;lt;- now we give the image representing the state here&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2021-12-06/contexts.png&quot; alt=&quot;contexts&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，我们调用Context的各函数，会发生：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Deadline&lt;/th&gt;
      &lt;th&gt;Done&lt;/th&gt;
      &lt;th&gt;Err&lt;/th&gt;
      &lt;th&gt;Value(foo)&lt;/th&gt;
      &lt;th&gt;Value(bar)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0, false&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0, false&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;done&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1.Value&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1.Value&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+1s, true&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;new a channel&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c.Value&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c.Value&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Deadline&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Done&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Value&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;baz&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Deadline&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;closedchan&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Canceled&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Value&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t.Value&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">在之前的文章中我们了解了Context的使用，我们很自然地会提出一些问题： Context被传递到多个goroutine中，如何保证没有data race？ 有CancelFunc的Context，如果不被取消，会有怎样的风险？ 父Context被取消，如何自动地使得所有子节点被取消？ Context的Value如果多次被同一个key写入值，结果会是怎样？ 听说Context以链表的形式存储Value，会不会有性能问题？ 带着这些问题，我们一同进入context包，看看Context的设计有着怎样的精妙之处与潜在的坑。 我们这里略过包的注释、Canceled, DeadlineExceeded error以及Context的定义（可以参见上一篇文章），直接从“原初”的emptyCtx开始。 注意，从下文开始，我们会在源码中加入形如⑴、⑵或㊟的记号，表示后续会进行详细阐释；如未特殊说明，//开头的注释为源码注释的翻译，/* */包围的注释为笔者所加评注。 源码与解析 源码来自go 1.17.3。 emptyCtx, Background()与TODO() // 一个emptyCtx不能被取消、没有Values或deadline。 // 它不是struct{}类型因为每个emptyCtx实例都需要不同的地址㊟。 type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() &amp;lt;-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } func (e *emptyCtx) String() string { /* 见下方 var background 和 todo */ switch e { case background: return &quot;context.Background&quot; case todo: return &quot;context.TODO&quot; } return &quot;unknown empty Context&quot; } var ( background = new(emptyCtx) todo = new(emptyCtx) ) /* 即，emptyCtx的实例有且仅有这里的 backgroud 与 todo */ // Background 返回非nil的空Context。它不能被取消、没有Values或deadline。 // 它被用于main函数、初始化、测试与顶层的请求。 func Background() Context { return background } // TODO 返回非nil的空Context。当不确定应该使用哪一个Context或Context暂时不可用 // （因该处的函数还没有被扩展以接收Context参数）时，代码应使用context.TODO。 func TODO() Context { return todo } ㊟ 为什么不使用 struct{}？ 请看下方代码片段： type S struct{} func s1() { s1, s2 := S{}, S{} println(&amp;amp;s1 == &amp;amp;s2) } func s2() { s1, s2 := S{}, S{} fmt.Printf(&quot;%p, %p, %t\n&quot;, &amp;amp;s1, &amp;amp;s2, &amp;amp;s1 == &amp;amp;s2) } func main() { s1() s2() } 请问输出应该是什么？答案是： false 0x119e408, 0x119e408, true 我们用go run -gcflags &apos;-m&apos; main.go运行，可以发现： ./main.go:19:2: moved to heap: s1 ./main.go:19:6: moved to heap: s2 ./main.go:20:43: &amp;amp;s1 == &amp;amp;s2 escapes to heap ./main.go:20:12: []interface {} literal does not escape 如果struct{}的实例逃逸到heap上，那它们的地址可能相同。事实上，The Go Programming Language Specification: Size and alignment guarantees确认了： A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory. struct或者array如果其不包含size大于0的字段，则其size为0。两个不同的size为0的变量可能拥有同一个地址。 因此，emptyCtx类型不使用struct{}，为了确保todo和background拥有不同的地址。 WithCancel与ConcelFunc // 一个CancelFunc告知相关操作应被取消。 // 一个CancelFunc并不等待操作结束。 // 一个CancelFunc可以被多个goroutine并发调用。 // 第一次调用后，对CancelFunc的随后调用无实际效果。 type CancelFunc func() // WithCancel 返回parent的一个拷贝以及一个新的Done channel。 // 在返回的cancel函数被调用时，或其父context的Done channel被关闭时， // 返回的context的Done channel被关闭。 // // 取消该context将释放相关的资源⑴， // 因此代码应该在本Context相关的操作结束时立即调用cancel。 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { if parent == nil { panic(&quot;cannot create context from nil parent&quot;) } c := newCancelCtx(parent) propagateCancel(parent, &amp;amp;c) return &amp;amp;c, func() { c.cancel(true, Canceled) } } // newCancelCtx 返回初始化后的cancelCtx实例。 func newCancelCtx(parent Context) cancelCtx { return cancelCtx{Context: parent} } // goroutines ...; 测试用。 var goroutines int32 // propagateCancel 使得parent被cancel时，cancel掉child。 func propagateCancel(parent Context, child canceler) { done := parent.Done() if done == nil { return // parent不能被cancel } select { case &amp;lt;-done: // 此时parent已经被cancel child.cancel(false, parent.Err()) return default: } /* parentCancelCtx 尝试返回parent的cancelCtx指针 */ if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { // parent 已经被cancel child.cancel(false, p.err) } else { if p.children == nil { p.children = make(map[canceler]struct{}) } p.children[child] = struct{}{} } p.mu.Unlock() } else { /* 例外，此时只能新启动协程监听parent.Done */ /* 例如parent恰好被cancel，或parent为非cancelCtx结构(没法通过children来cancel) */ atomic.AddInt32(&amp;amp;goroutines, +1) go func() { select { case &amp;lt;-parent.Done(): child.cancel(false, parent.Err()) case &amp;lt;-child.Done(): } }() } } // &amp;amp;cancelCtxKey 为cancelCtx返回其自身的指针值的key。 var cancelCtxKey int // parentCancelCtx 返回承载parent的*cancelCtx。 // 本函数通过查parent.Value(&amp;amp;cancelCtxKey)来找到最里层的*cancelCtx， // 并检查parent.Done()是否匹配该*cancelCtx。 // （如果不匹配，则该*cancelCtx已被嵌入非默认的、提供不同done channel的实现中， // 此时我们不应绕过该它⑵。） func parentCancelCtx(parent Context) (*cancelCtx, bool) { done := parent.Done() if done == closedchan || done == nil { return nil, false } p, ok := parent.Value(&amp;amp;cancelCtxKey).(*cancelCtx) if !ok { return nil, false } pdone, _ := p.done.Load().(chan struct{}) if pdone != done { return nil, false } return p, true } // removeChild 从parent处移除该context。 func removeChild(parent Context, child canceler) { p, ok := parentCancelCtx(parent) if !ok { return } p.mu.Lock() if p.children != nil { delete(p.children, child) } p.mu.Unlock() } // 一个canceler为可以被直接cancel的context类型。 // 实现包括：*cancelCtx和*timerCtx。 type canceler interface { cancel(removeFromParent bool, err error) Done() &amp;lt;-chan struct{} } // closedchan 为用于复用的、代表已关闭的channel⑶。 /* 在init中确保closedchan被关闭 */ var closedchan = make(chan struct{}) func init() { close(closedchan) } // cancelCtx实例可以被cancel。当其被cancel， // 该实例也将cancel其所有实现了canceler的子节点 type cancelCtx struct { Context /* 此即parent Context */ mu sync.Mutex // mu用于保护下列字段 done atomic.Value // 延迟创建的done用于存储chan struct{} // 并在第一次cancel时被关闭 children map[canceler]struct{} // 第一次cancel将该字段设为nil err error // 第一次cancel将该字段设为非nil } func (c *cancelCtx) Value(key interface{}) interface{} { if key == &amp;amp;cancelCtxKey { return c } return c.Context.Value(key) /* 在parent的Value中查找 */ } func (c *cancelCtx) Done() &amp;lt;-chan struct{} { d := c.done.Load() if d != nil { return d.(chan struct{}) } c.mu.Lock() defer c.mu.Unlock() d = c.done.Load() if d == nil { d = make(chan struct{}) c.done.Store(d) } return d.(chan struct{}) } func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } type stringer interface { String() string } func contextName(c Context) string { if s, ok := c.(stringer); ok { return s.String() } return reflectlite.TypeOf(c).String() } func (c *cancelCtx) String() string { return contextName(c.Context) + &quot;.WithCancel&quot; } // cancel 关闭c.done、cancel所有c的子Context，且如果 // removeFromParent为true，则将其从parent的children中移除 func (c *cancelCtx) cancel(removeFromParent bool, err error) { if err == nil { panic(&quot;context: internal error: missing cancel error&quot;) } c.mu.Lock() if c.err != nil { c.mu.Unlock() return // 已经被cancel过 } c.err = err d, _ := c.done.Load().(chan struct{}) if d == nil { // done还没被使用chan struct{}创建 c.done.Store(closedchan) } else { close(d) } for child := range c.children { // 注意：此时持有parent的锁，并申请child的锁 child.cancel(false, err) } c.children = nil c.mu.Unlock() if removeFromParent { removeChild(c.Context, c) } } ⑴ 完成后立即cancel 源码的注释或go vet都要求我们在操作完成后立即调用cancel保证资源及时释放，例如通过defer cancel()的方式。那么对于cancelCtx，及时cancel释放了什么资源？ 一是我们留意到，propagateCancel这里有如下函数： go func() { select { case &amp;lt;-parent.Done(): child.cancel(false, parent.Err()) case &amp;lt;-child.Done(): } }() 即某种情况下，可能需要新增协程来监听parent或自身的done channel，如果及时cancel则该协程会及时退出。（至于什么时候会新增协程来监听，见注释⑵。） 第二点，显然cancel可以使得本context从parent.children中移除；并且，这是在parent不被cancel的情况下，唯一释放该child的方法。经测试，parent为*cancelCtx，以此调用1000000次WithCancel然后直接返回，系统内存占用为205MB，如果child都立即被cancel，则系统内存占用为70MB。 三也很显然，cancel该Context后，所有子节点都会被cancel掉，从而可以使得更多地资源被及时回收。 ⑵ parentCancelCtx 为什么通过p, ok := parent.Value(&amp;amp;cancelCtxKey).(*cancelCtx)找到*cancelCtx（即ok == true）之后，还需要确保pDone == p呢？ 看如下代码： type CustomContext struct { context.Context c chan struct{} } func (c *CustomContext) Done() &amp;lt;-chan struct{} { return c.c } 这里，如果CustomContext.Context为*cancelCtx，且被传入context.WithCancel，那么在parentCancelCtx中会找到CustomContext.Context，但这里如果直接返回，就返回的是祖父节点的的指针。 我们也可以用如下代码验证： func main() { println(runtime.NumGoroutine()) // 1 inner, cancel := context.WithCancel(context.Background()) defer cancel() c := &amp;amp;CustomContext{inner, make(chan struct{})} _, cancel2 := context.WithCancel(c) defer cancel2() println(runtime.NumGoroutine()) // 2 } 正因为WithCancel的操作，新增了一个goroutine用于监听c.Done()。 ⑶ closedchan 为什么需要全局变量（且专门在init中close掉的）closedchan？ 这是因为，done的注释说明了该chan struct{}是延迟创建的，且正好是被调用Done时创建，如果一个Context尚未被调用Done就被cancel了，那么如果没有closedchan则需要新创建一个channel并立即close掉。 WithDeadline与WithTimeout // WithDeadline 返回附有截止时间不晚于d的parent的拷贝。 // 如果parent的deadline早于d， // WithDeadline(parent, d)语义上与parent相同。 // 返回的Context的Done channel将被关闭，当下列任一情况满足： // 到达截止时间，或 // 返回的cancel函数被调用，或 // parent的Done channel被关闭。 // // 取消该context将释放相关的资源㊟， // 因此代码应该在本Context相关的操作结束时立即调用cancel。 func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { if parent == nil { panic(&quot;cannot create context from nil parent&quot;) } if cur, ok := parent.Deadline(); ok &amp;amp;&amp;amp; cur.Before(d) { // 已有的截止时间早于参数d return WithCancel(parent) } c := &amp;amp;timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) dur := time.Until(d) if dur &amp;lt;= 0 { c.cancel(true, DeadlineExceeded) // 截止时间已超过 return c, func() { c.cancel(false, Canceled) } /* 此时返回的c已被cancel */ } c.mu.Lock() /* 因为可能此时parent被cancel，所以需要用c.mu保护 */ defer c.mu.Unlock() if c.err == nil { /* 也是防止在获取锁之前因parent而被cancel */ c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } // timerCtx实例包含一个计时器与截止时间。它嵌入了一个cancelCtx来实现Done与Err。 // 它通过停止其计时器并使用cancelCtx.cancel来实现cancel。 type timerCtx struct { cancelCtx timer *time.Timer // 受cancelCtx.mu保护。 deadline time.Time } func (c *timerCtx) Deadline() (deadline time.Time, ok bool) { return c.deadline, true } func (c *timerCtx) String() string { return contextName(c.cancelCtx.Context) + &quot;.WithDeadline(&quot; + c.deadline.String() + &quot; [&quot; + time.Until(c.deadline).String() + &quot;])&quot; } func (c *timerCtx) cancel(removeFromParent bool, err error) { c.cancelCtx.cancel(false, err) if removeFromParent { // 从parent处移除c removeChild(c.cancelCtx.Context, c) /* 真正的parent是c.cancelCtx.Context */ } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } // WithTimeout 返回WithDeadline(parent, time.Now().Add(timeout))。 // // 取消该context将释放相关的资源， // 因此代码应该在本Context相关的操作结束时立即调用cancel： // // func slowOperationWithTimeout(ctx context.Context) (Result, error) { // ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond) // defer cancel() // 如果slowOperation在超时之前就完成了，则释放资源 // return slowOperation(ctx) // } func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } ㊟ 完成后立即cancel 这里需要及时cancel的原因与cancelCtx类似，只不过有timer兜底，不会“永远地”内存泄漏。 WithValue // WithValue 返回parent的拷贝，并附上key对应的值val。 // // 仅对不同进程与API间转移的请求范畴内的数据使用context的Value， // 而不是用以传递函数的可选参数。 // // 提供的key必须是可比较的类型，且为避免在各使用context的包内冲突， // 它不应是字符串或任意内置类型。使用WithValue的用户应自定义key的类型。 // 为避免赋值给interface{}时的内存分配，context key通常使用类型struct{}。 // 另外，导出的context key变量的静态类型应该为pointer或interface。 func WithValue(parent Context, key, val interface{}) Context { if parent == nil { panic(&quot;cannot create context from nil parent&quot;) } if key == nil { panic(&quot;nil key&quot;) } if !reflectlite.TypeOf(key).Comparable() { panic(&quot;key is not comparable&quot;) } return &amp;amp;valueCtx{parent, key, val} } // valueCtx实例携带key-value pair。它对该key实现了Value函数， // 并使用嵌入的Context来应对其余函数调用。 It implements Value for that key and // delegates all other calls to the embedded Context. type valueCtx struct { Context key, val interface{} } // stringify 尝试在不使用fmt的情况下将v转换为字符串，这是因为 // context并不希望依赖unicode表。本函数仅在*valueCtx.String()中使用。 func stringify(v interface{}) string { switch s := v.(type) { case stringer: return s.String() case string: return s } return &quot;&amp;lt;not Stringer&amp;gt;&quot; } func (c *valueCtx) String() string { return contextName(c.Context) + &quot;.WithValue(type &quot; + reflectlite.TypeOf(c.key).String() + &quot;, val &quot; + stringify(c.val) + &quot;)&quot; } /* Value 以类似链表的形式实现，我们在稍后会讨论到 */ func (c *valueCtx) Value(key interface{}) interface{} { if c.key == key { return c.val } return c.Context.Value(key) } 对Context的批评（并尝试回应） 批评 Michal Štrba在文章Context should go away for Go 2中批评了Context的设计，甚至说： If you use ctx.Value in my (non-existent) company, you’re fired. 如果你在我（并不存在的）公司中使用ctx.Value，你将被开除。 TA的指责主要可以总结为： 从请求生命周期开始到结束的每一个函数，即使有的并不需要使用到ctx，也被迫需要将其作为第一个参数。 Context is like a virus. context.Value问题重重： 并非静态类型安全，需要类型断言。 存储的内容并非静态可感知。 可能命名冲突造成问题。 使用类似于链表的结构，存在性能问题。 ctx context.Context看起来就很啰嗦（然后TA顺便黑了一下Java：让人想起Foo foo = new Foo();）。 这里，我们尝试对Michal Štrba的观点作一个回应。 回应 cxt污染 Context本来就是用于控制请求的生命周期的，所以很自然地从始至终需要传递；退一步讲，如果换其他实现，想达到能控制整个请求生命周期的目的，也需要始终传递某个参数——不然怎么能实现“控制整个请求生命周期”？ 以及，并不是所有核请求相关的函数都需要ctx参数，那些与API调用无关的过程自然也就不需要该参数——该参数仅存在于请求的“主干”上。Michal Štrba其实误解了Context的用法。 Value的问题 的确，没有固定类型的Value是代价，但换取的是灵活性。我们总能想起来“但是，古尔丹，代价是什么呢”，那么我们也应该想到，“但是，gopher，代价带来的是什么呢”。 我们考虑以下两点，其实可以或多或少地排除掉这个顾虑： 正如源码文档所写，应该使用存取函数来完成值的读写，而不是直接操纵ctx.Value本身；并且，key都使用非导出的包作用域的变量，自然不会存在冲突的问题； 在此前的文章The Context of the Package context中，我们非常认可Jack Lindamood在Gophercon UK 2017所述：Context.Value should inform, not control；真正必不可少的“参数”，应该是通过函数参数来传递，而不是Context——这也在源码文档里有专门提到。 性能问题 首先回应Michal Štrba指责的，cancelCtx有时需要goroutine来通知，但通常我们不会去重定义Context的Done返回的channel，实际上你是否能想到非得重定义Done的行为的必要场景？ 其次是，Context之间的内嵌使得节点关系是近似于链表的结构，而不是更高效的数据结构。比如很容易想到的，WithValue竟然是通过新增Context节点来完成的。 那这个代价换来了什么？换来的是严格意义上的父子节点的关系。或者思考，如何实现一个仅能访问自身节点与祖先节点所存储的数据的结构？ 并且我们退一步讲，代价究竟有多大。首先，WithValue并不是一个应该被频繁调用的函数，这点我们不再赘述，所以用于存储Value的这部分链表的长度其实是有限的；其次是，对于cancel被传递下去的代价是什么，其实回顾cancelCtx或timerCtx的代码，可以发现里面的操作都是必须的，并没有什么冗余，且基本没有需要等待channel的情况（如果不考虑重新定义Done返回的channel这一情况）。 实际上，我们测试了，通过连续调用1000次WithCancel，然后第一个Context的cancel被调用，第1000个Context平均在0.10ms后Done()接收到结果。要留意到，Context是用来控制耗时以毫秒为单位的请求的，似乎看起来Context本身的开销其实微乎其微。 啰嗦 Emmm，除非把Context设为内置类型并缩短命名，使得可以变为func (ctx Ctx)外，好像没啥好说的。 小结 我们对Context提出诘难的时候也应该思考，我们是否真正用对了Context，我们是否有更好的解决方法呢？ 解答提出的问题 如何保证没有data race 看了代码可以知道，todo/background无需保护、cancelCtx使用mutex和原子操作来保护done、children和err、timerCtx嵌入了cancelCtx并以其mutex保护自己的timer，而valueCtx的key-value pair都是只读的，因此不用担心data race。 不过这里需要注意的是，Context.Value不应存储并发访问不安全的数据。 关于cancel 通过代码，我们知道了cancel的传递（在非自定义Done返回的channel的情况下）是通过cancelCtx.children来完成的；cancelCtx的子节点不手动cancel的话，可能会使得parent.children持续膨胀，导致泄露。 关于重复赋值value 请不要重复赋值value。但阅读代码之后可以发现，Value的调用是从子节点回溯到祖先节点，因此会找到最新的value（但并不会覆盖原有值）。 func main() { // 注意，不要用内置类型作为key的类型 c1 := context.WithValue(context.Background(), hello, &quot;world&quot;) c2 := context.WithValue(c1, foo, &quot;bar&quot;) c3 := context.WithValue(c2, hello, &quot;today&quot;) c4 := context.WithValue(c3, bar, &quot;baz&quot;) fmt.Println(c4.Value(hello)) // today fmt.Println(c2.Value(hello)) // world } 关于性能问题 在上一节已经探讨过了，不再赘述。 总结 关于Context的使用，请参加之前的文章《使用context包轻松完成并发控制》。 我们以如下代码行的示意图图来作结： v1 := context.WithValue(context.Background(), foo, 1) c, cancel := context.WithCancel(v1) defer cancel() done := c.Done() t, cancel1 := context.WithTimeout(c, time.Second) defer cancel2() v2 := context.WithValue(t, bar, &quot;baz&quot;) c2, cancel3 := context.WithCancel(t) cancel3() // &amp;lt;- now we give the image representing the state here return 此时，我们调用Context的各函数，会发生：   Deadline Done Err Value(foo) Value(bar) v1 0, false nil nil 1 nil c 0, false done nil v1.Value v1.Value t +1s, true new a channel nil c.Value c.Value v2 t.Deadline t.Done nil t.Value &quot;baz&quot; c2 t.Deadline closedchan Canceled t.Value t.Value</summary></entry><entry><title type="html">深入Go：使用context包轻松完成并发控制</title><link href="http://localhost:4000/2021/11/30/%E6%B7%B1%E5%85%A5Go-%E4%BD%BF%E7%94%A8context%E5%8C%85%E8%BD%BB%E6%9D%BE%E5%AE%8C%E6%88%90%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.html" rel="alternate" type="text/html" title="深入Go：使用context包轻松完成并发控制" /><published>2021-11-30T00:00:00+00:00</published><updated>2021-11-30T00:00:00+00:00</updated><id>http://localhost:4000/2021/11/30/%E6%B7%B1%E5%85%A5Go:%E4%BD%BF%E7%94%A8context%E5%8C%85%E8%BD%BB%E6%9D%BE%E5%AE%8C%E6%88%90%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/2021/11/30/%E6%B7%B1%E5%85%A5Go-%E4%BD%BF%E7%94%A8context%E5%8C%85%E8%BD%BB%E6%9D%BE%E5%AE%8C%E6%88%90%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.html">&lt;p&gt;Package &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 的引入是 Go 1.7 的重要特性。但好像在实践中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt; 并没有太出现在我们的视野中；实际上，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes/client-go&lt;/code&gt; &lt;a href=&quot;https://github.com/kubernetes/client-go/commit/1faf9e8d03b91c5c5529e1ac8ed6838fb6248049#diff-44c36ff04d213cbb389bfe45b53a1aae22bb37d2fb6ba7d1483ad9373724d725&quot;&gt;直到2020年&lt;/a&gt;才逐渐完善地将 package &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context &lt;/code&gt; 融入其中。&lt;/p&gt;

&lt;p&gt;之前在公司技术论坛有过一个问题“Go后台耗时优化方面有什么心得可以分享吗”，其中很多回答都有提到“并发”（实际上我们在项目实践中也是尽可能充分使用Go并发的能力），我们也发现package &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;也可以极大地方便我们进行并发过程的管理。现在结合GopherCon UK 2017的&lt;a href=&quot;https://www.gophercon.co.uk/videos/2017/how-to-correctly-use-package-context/&quot;&gt;talk&lt;/a&gt;中的技巧与我们实践中的经验，总结出了这篇文章 &lt;em&gt;The Context of the Package &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;太长不看版&quot;&gt;太长不看版&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.Context&lt;/code&gt;可以被用于管理以一次请求为基础的过程，包括控制超时与完成、传递请求参数等。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithValue(parent Context, key interface{}, val interface{}) Context&lt;/code&gt; 用于增加请求相关的上下文内容，例如鉴权信息（注意，它并不被设计用来“传递函数参数”，详见后文）；key应该使用非导出类型的非导出全局变量；包应该提供封装好的类型安全的函数用于值的存取。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithCancel(parent Context) (ctx Context, cancel CancelFunc)&lt;/code&gt; 提供context的取消入口。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)&lt;/code&gt; 提供context的超时功能，类似的还有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;获得的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel&lt;/code&gt;函数应该被立即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;defer cancel()&lt;/code&gt;，以便过程结束后该Context及时被回收，见&lt;a href=&quot;https://go.dev/doc/database/cancel-operations&quot;&gt;Cancelling in-progress operations&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;通过上述函数创建的Context结构体自动构成从父节点到子节点的树状关系，一旦某个父节点超时/被取消，其所有后代节点自动超时/被取消。&lt;/li&gt;
  &lt;li&gt;监听是否超时/被取消，可使用结构体的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Done()&lt;/code&gt;函数获取对应channel。&lt;/li&gt;
  &lt;li&gt;根节点（包括在main中或测试中）可使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.Backgroud()&lt;/code&gt;来创建；如果暂不确定，可使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.TODO()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;启动并发任务并等待每个任务完成&quot;&gt;启动并发任务并等待每个任务完成&lt;/h5&gt;

&lt;p&gt;逻辑比较简单，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errgroup&lt;/code&gt;即可；我们以两个并发任务为例：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;&quot;context&quot;&lt;/span&gt;
  
        &lt;span class=&quot;s&quot;&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Handler 并发调用 f1, f2 获取字符串并返回，如果其中一个错误则直接返回得到的错误&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errgroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  
      &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 新启动协程完成获取s1&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
  
      &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 新启动协程完成获取s2&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// 等候两个协程完成，其中一个出现错误则立即返回，其他协程也会收到ctx.Done()的信号&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;启动并发任务等待最快返回的结果&quot;&gt;启动并发任务等待最快返回的结果&lt;/h5&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// pseudo-preprocess&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果preprocess结束发现已经被取消/超时，则直接退出&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Canceled&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 否则开始执行&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;now we begin:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// pseudo-execute&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strconv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Itoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goroutineNum&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 为避免发送的线程阻塞造成goroutine泄漏，应使用 buffered channel&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 创建 context 的 cancle 函数&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// return结果时就取消尚未执行的任务&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goroutineNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;now we got:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 由于是buffered channel，因此即使没有接收方也不会阻塞&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;in main:&quot;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一次执行：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;got&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;got&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canceled&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（太长不看版结束）&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;why-context&quot;&gt;Why Context?&lt;/h2&gt;

&lt;h3 id=&quot;应对请求时服务应该具备的能力&quot;&gt;应对请求时，服务应该具备的能力&lt;/h3&gt;

&lt;p&gt;当我们的服务在面对请求时，应该具备：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;依赖模块/服务超时的检测的能力；&lt;/li&gt;
  &lt;li&gt;并发任务中，当正在进行的并发任务的结果不再被需要时（例如某一个任务返回了错误或超时），取消其他并发任务的能力；&lt;/li&gt;
  &lt;li&gt;控制一整个任务的超时情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如，我们的服务在接收查询请求之后，需要进行鉴权、查询数据库里关联信息、查询对应Pod的状态、如果Pod故障查询相关事件、查询ElasticSearch或k8s以对应Pod的日志（取最快的那个）。我们希望该请求的处理能尽可能并发进行，于是过程对应下图的调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;flowchart LR
  begin(收到查询请求) --&amp;gt; auth[鉴权]
  begin --&amp;gt; db[查询数据库] --&amp;gt; k8s[查询 Pod 状态] --&amp;gt; event[查询 events]
  db --&amp;gt; log[查询日志] -.-&amp;gt; k8s_log[查询 k8s 获取日志]
  log -.-&amp;gt; es[查询 ElasticSearch 获取日志]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设要求请求需要在3秒内返回，否则超时；很自然我们要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果请求超时，所有正在进行的过程被取消；&lt;/li&gt;
  &lt;li&gt;ES 或 k8s 获取到日志，另一个查询途径的请求取消；&lt;/li&gt;
  &lt;li&gt;如果任一环节失败，其他所有正在进行的并发任务应该被取消，直接以对应错误进行响应。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，我们的代码应该如何设计？&lt;/p&gt;

&lt;h3 id=&quot;context的能力&quot;&gt;Context的能力&lt;/h3&gt;

&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.Context&lt;/code&gt;，我们可以很方便地控制并发任务的超时与取消。&lt;/p&gt;

&lt;p&gt;为满足上述条件，只需要在查询请求开始，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.WithTimeout(3 * time.Second)&lt;/code&gt;，并利用返回的Context进行后续的任务；并发任务一个错误即取消所有，参看上文的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errgroup&lt;/code&gt;的使用；这里我们给出应对查询请求的函数以及获取Pod状态的函数：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getPodResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;podName&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failureReason&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果已取消，则直接返回&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;podStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getPodStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;podName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isSuccessful&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;podStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;podStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果已取消，则直接返回&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;failureReason&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getFailureReason&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;podName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;podStatus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failureReason&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetInfoRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetInfoResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 请求总计3秒超时&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errgroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// errgroup也会给ctx注册cancel函数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NoPermissionError&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetInfoResponse&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TaskID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// query DB, pod and logs; use errgroup&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-context-of-contextcontext&quot;&gt;The Context of context.Context&lt;/h2&gt;

&lt;h3 id=&quot;context-结构体&quot;&gt;Context 结构体&lt;/h3&gt;

&lt;p&gt;Package &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;结构体长这样（把英文注释翻译为了中文，原文见&lt;a href=&quot;https://pkg.go.dev/context#Context&quot;&gt;这里&lt;/a&gt;），Go的注释也详细解释了Context应被怎样使用，尤其是关于其Value应该被怎样使用：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Deadline返回该context对应的超时取消时间。若未设置截止时间，则返回的ok==false。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 连续调用Deadline函数将返回同样的结果。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Done 返回通过调用对应cancel函数来表示任务完成时即被关闭的channel。如果context无法被取消，则Done返回nil. 连续调用Done函数将返回同样的结果。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Done channel可能会在cancel被调用之后异步地被关闭。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// WithCancel 使得当cancel被调用时，Done channel被关闭；&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// WithDeadline 使得当截止时间超过时，Done channel被关闭；&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// WithTimeout 使得当超时时，Done channel被关闭。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Done可被用于select语句:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//  // Stream 通过调用DoSomething产生输出并发送至out，直至&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//  // DoSomething返回错误或ctx.Done被关闭。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//  func Stream(ctx context.Context, out chan&amp;lt;- Value) error {&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//      for {&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          v, err := DoSomething(ctx)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          if err != nil {&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//              return err&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          }&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          select {&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          case &amp;lt;-ctx.Done():&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//              return ctx.Err()&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          case out &amp;lt;- v:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//          }&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//      }&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//  }&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 更多使用Done channel进行任务取消的例子见：&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// https://blog.golang.org/pipelines&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// 如果Done尚未被关闭, Err将返回nil。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 如果Done尚已被关闭, Err将返回非nil错误，其说明了关闭原因：&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Canceled 当context被cancel，或者&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// DeadlineExceeded 当超过截止时间。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 当Err返回非nil error后, 连续调用Err函数将返回同样的结果。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Value 返回本context中对应key的值，如果没有该key对应的值则返回nil。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 使用同样的key来连续调用Value函数将返回同样的结果。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 仅对请求基础上的、在不同过程或API范围内的数据使用context，&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 而不要将此作为传递函数可选参数的方式。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 一个key用于确定Context中的一个特定的值。&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 希望在Context中存储值的函数通常使用全局变量来作为context.WithValue和Context.Value的参数。&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// key可以是任意支持相等比较的类型；包应该定义key为非导出类型以避免碰撞。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 定义Context key的包需要为相应的值提供类型安全的访问入口：&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // Package user定义了存储于Context中的User类型。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     package user&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     import &quot;context&quot;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // User 是存储于Context中的类型。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     type User struct {...}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // key是本package中非导出的类型。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // 其避免了与其他包中定义的key类型产生冲突。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     type key int&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // userKey为存储在Context中的user.User值的对应的key。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // 它是非导出的；使用方应使用user.NewContext和user.FromContext函数，而不是&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // 直接使用本key。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     var userKey key&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // NewContext 返回保存了u的Context。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     func NewContext(ctx context.Context, u *User) context.Context {&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//         return context.WithValue(ctx, userKey, u)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     }&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     // FromContext 返回ctx中保存的User类型值。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     func FromContext(ctx context.Context) (*User, bool) {&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//         u, ok := ctx.Value(userKey).(*User)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//         return u, ok&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//     }&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;contextvalue的注意事项&quot;&gt;Context.Value的注意事项&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Value仅用于存储和Context生命周期相关的数据，而不是用来传递可选参数的；&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;由此，Value里的值应该是设置后不应更改的；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Value的key应该使用包内非导出的类型定义的非导出的全局变量，值的存取应该使用包提供的类型安全的函数而不是直接操纵&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context.Value&lt;/code&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Value中存在的值作为必不可少的参数时，为了高可读性，也不应该通过Context去获取，例如下方函数，即使&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uin&lt;/code&gt;和本次请求强绑定并存到了Context中，也应该显式地作为函数参数，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func IsAdmin(ctx context.Context, uin string) (bool, error)&lt;/code&gt;。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context.Value&lt;/code&gt; should inform, not control.&lt;/p&gt;

      &lt;p&gt;–Jack Lindamood&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;树状contexts&quot;&gt;树状Contexts&lt;/h3&gt;

&lt;p&gt;新创建的Context总是原有Context的子节点，并受原有Context的Deadline、cancel、Value影响。例如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testWithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelB2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelB2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelC3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelC3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelD3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelD3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelE2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WithCancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cancelE2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancelB2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;d3 is canceled:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;e2 is not canceled yet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/*
0001-01-01 00:00:00 false
2021-11-29 20:29:44.839665 m=+60.001770296 true
2021-11-29 20:29:44.839665 m=+60.001770296 true // 受父节点的1分钟超时影响，新设置1小时超时无效
2021-11-29 20:28:45.839691 m=+1.001796617 true  // 新设置的1秒后超时
d3 is canceled: context canceled                // 因为父节点被cancel
e2 is not canceled yet                          // 不受非祖先节点的其他节点影响
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;其他注意事项总结&quot;&gt;其他注意事项、总结&lt;/h2&gt;

&lt;p&gt;去看“太长不看版”。关于context源码的解读可见下一篇文章。&lt;/p&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">Package context 的引入是 Go 1.7 的重要特性。但好像在实践中，context 并没有太出现在我们的视野中；实际上，kubernetes/client-go 直到2020年才逐渐完善地将 package context 融入其中。 之前在公司技术论坛有过一个问题“Go后台耗时优化方面有什么心得可以分享吗”，其中很多回答都有提到“并发”（实际上我们在项目实践中也是尽可能充分使用Go并发的能力），我们也发现package context也可以极大地方便我们进行并发过程的管理。现在结合GopherCon UK 2017的talk中的技巧与我们实践中的经验，总结出了这篇文章 The Context of the Package context。 太长不看版 context.Context可以被用于管理以一次请求为基础的过程，包括控制超时与完成、传递请求参数等。 WithValue(parent Context, key interface{}, val interface{}) Context 用于增加请求相关的上下文内容，例如鉴权信息（注意，它并不被设计用来“传递函数参数”，详见后文）；key应该使用非导出类型的非导出全局变量；包应该提供封装好的类型安全的函数用于值的存取。 WithCancel(parent Context) (ctx Context, cancel CancelFunc) 提供context的取消入口。 WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 提供context的超时功能，类似的还有WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)。 获得的cancel函数应该被立即 defer cancel()，以便过程结束后该Context及时被回收，见Cancelling in-progress operations。 通过上述函数创建的Context结构体自动构成从父节点到子节点的树状关系，一旦某个父节点超时/被取消，其所有后代节点自动超时/被取消。 监听是否超时/被取消，可使用结构体的Done()函数获取对应channel。 根节点（包括在main中或测试中）可使用context.Backgroud()来创建；如果暂不确定，可使用context.TODO()。 启动并发任务并等待每个任务完成 逻辑比较简单，用errgroup即可；我们以两个并发任务为例： import ( &quot;context&quot; &quot;golang.org/x/sync/errgroup&quot; ) // Handler 并发调用 f1, f2 获取字符串并返回，如果其中一个错误则直接返回得到的错误 func Handler(ctx context.Context) ([]string, error) { eg, ctx := errgroup.WithContext(ctx) ret := make([]string, 2) eg.Go(func() error { // 新启动协程完成获取s1 s1, err := f1(ctx) if err != nil { return err } ret[0] = s1 }) eg.Go(func() error { // 新启动协程完成获取s2 s2, err := f2(ctx) if err != nil { return err } ret[1] = s2 }) // 等候两个协程完成，其中一个出现错误则立即返回，其他协程也会收到ctx.Done()的信号 if err := eg.Wait(); err != nil { return nil, err } return ret } 启动并发任务等待最快返回的结果 func do(ctx context.Context, i int) (string, error) { r1, r2 := rand.Intn(10000), rand.Intn(10000) time.Sleep(time.Duration(r1) * time.Millisecond) // pseudo-preprocess select { case &amp;lt;-ctx.Done(): // 如果preprocess结束发现已经被取消/超时，则直接退出 return &quot;&quot;, context.Canceled default: // 否则开始执行 println(&quot;now we begin:&quot;, i) } time.Sleep(time.Duration(r2) * time.Millisecond) // pseudo-execute return strconv.Itoa(i), nil } func Vroom(ctx context.Context, goroutineNum int) string { // 为避免发送的线程阻塞造成goroutine泄漏，应使用 buffered channel ch := make(chan string, goroutineNum) ctx, cancel := context.WithCancel(ctx) // 创建 context 的 cancle 函数 defer cancel() // return结果时就取消尚未执行的任务 for i := 0; i &amp;lt; goroutineNum; i++ { go func(index int) { x, err := do(ctx, index) if err != nil { println(index, &quot;:&quot;, err.Error()) return } println(&quot;now we got:&quot;, x) ch &amp;lt;- x // 由于是buffered channel，因此即使没有接收方也不会阻塞 }(i) } return &amp;lt;-ch } func main() { x := Vroom(context.Background(), 3) println(&quot;in main:&quot;x) time.Sleep(10 * time.Second) } 一次执行： now we begin: 0 now we begin: 1 now we got: 1 in main: 1 now we got: 0 2 : context canceled （太长不看版结束） Why Context? 应对请求时，服务应该具备的能力 当我们的服务在面对请求时，应该具备： 依赖模块/服务超时的检测的能力； 并发任务中，当正在进行的并发任务的结果不再被需要时（例如某一个任务返回了错误或超时），取消其他并发任务的能力； 控制一整个任务的超时情况。 例如，我们的服务在接收查询请求之后，需要进行鉴权、查询数据库里关联信息、查询对应Pod的状态、如果Pod故障查询相关事件、查询ElasticSearch或k8s以对应Pod的日志（取最快的那个）。我们希望该请求的处理能尽可能并发进行，于是过程对应下图的调用： flowchart LR begin(收到查询请求) --&amp;gt; auth[鉴权] begin --&amp;gt; db[查询数据库] --&amp;gt; k8s[查询 Pod 状态] --&amp;gt; event[查询 events] db --&amp;gt; log[查询日志] -.-&amp;gt; k8s_log[查询 k8s 获取日志] log -.-&amp;gt; es[查询 ElasticSearch 获取日志] 假设要求请求需要在3秒内返回，否则超时；很自然我们要求： 如果请求超时，所有正在进行的过程被取消； ES 或 k8s 获取到日志，另一个查询途径的请求取消； 如果任一环节失败，其他所有正在进行的并发任务应该被取消，直接以对应错误进行响应。 那么，我们的代码应该如何设计？ Context的能力 使用context.Context，我们可以很方便地控制并发任务的超时与取消。 为满足上述条件，只需要在查询请求开始，调用context.WithTimeout(3 * time.Second)，并利用返回的Context进行后续的任务；并发任务一个错误即取消所有，参看上文的errgroup的使用；这里我们给出应对查询请求的函数以及获取Pod状态的函数： func getPodResult(ctx context.Context, podName string) ( status, failureReason string, err error) { select { case err = &amp;lt;-ctx.Done(): // 如果已取消，则直接返回 return &quot;&quot;, &quot;&quot;, err default: } podStatus := getPodStatus(ctx, podName) if isSuccessful(podStatus) { return podStatus, &quot;&quot;, nil } select { case err = &amp;lt;-ctx.Done(): // 如果已取消，则直接返回 return &quot;&quot;, &quot;&quot;, err default: } failureReason, err := getFailureReason(ctx, podName) return podStatus, failureReason, err } func Handle(ctx context.Context, req *GetInfoRequest) (*GetInfoResponse, error) { ctx, cancel := context.WithTimeout(ctx, 3*time.Second) // 请求总计3秒超时 defer cancel() eg, ctx := errgroup.WithContext(ctx) // errgroup也会给ctx注册cancel函数 eg.Go( func() error { ok, err := Auth(ctx, req) if err != nil { return err } if !ok { return NoPermissionError } return nil }) var rsp *GetInfoResponse eg.Go( func() error { var err error rsp, err = query(ctx, req.TaskID) // query DB, pod and logs; use errgroup if err != nil { return err } return nil }) if err := eg.Wait(); err != nil { return nil, err } return rsp, nil } The Context of context.Context Context 结构体 Package context中的Context结构体长这样（把英文注释翻译为了中文，原文见这里），Go的注释也详细解释了Context应被怎样使用，尤其是关于其Value应该被怎样使用： type Context interface { // Deadline返回该context对应的超时取消时间。若未设置截止时间，则返回的ok==false。 // 连续调用Deadline函数将返回同样的结果。 Deadline() (deadline time.Time, ok bool) // Done 返回通过调用对应cancel函数来表示任务完成时即被关闭的channel。如果context无法被取消，则Done返回nil. 连续调用Done函数将返回同样的结果。 // Done channel可能会在cancel被调用之后异步地被关闭。 // // WithCancel 使得当cancel被调用时，Done channel被关闭； // WithDeadline 使得当截止时间超过时，Done channel被关闭； // WithTimeout 使得当超时时，Done channel被关闭。 // // Done可被用于select语句: // // // Stream 通过调用DoSomething产生输出并发送至out，直至 // // DoSomething返回错误或ctx.Done被关闭。 // func Stream(ctx context.Context, out chan&amp;lt;- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case &amp;lt;-ctx.Done(): // return ctx.Err() // case out &amp;lt;- v: // } // } // } // // 更多使用Done channel进行任务取消的例子见： // https://blog.golang.org/pipelines Done() &amp;lt;-chan struct{} // 如果Done尚未被关闭, Err将返回nil。 // 如果Done尚已被关闭, Err将返回非nil错误，其说明了关闭原因： // Canceled 当context被cancel，或者 // DeadlineExceeded 当超过截止时间。 // 当Err返回非nil error后, 连续调用Err函数将返回同样的结果。 Err() error // Value 返回本context中对应key的值，如果没有该key对应的值则返回nil。 // 使用同样的key来连续调用Value函数将返回同样的结果。 // // 仅对请求基础上的、在不同过程或API范围内的数据使用context， // 而不要将此作为传递函数可选参数的方式。 // // 一个key用于确定Context中的一个特定的值。 // 希望在Context中存储值的函数通常使用全局变量来作为context.WithValue和Context.Value的参数。 // key可以是任意支持相等比较的类型；包应该定义key为非导出类型以避免碰撞。 // // 定义Context key的包需要为相应的值提供类型安全的访问入口： // // // Package user定义了存储于Context中的User类型。 // package user // // import &quot;context&quot; // // // User 是存储于Context中的类型。 // type User struct {...} // // // key是本package中非导出的类型。 // // 其避免了与其他包中定义的key类型产生冲突。 // type key int // // // userKey为存储在Context中的user.User值的对应的key。 // // 它是非导出的；使用方应使用user.NewContext和user.FromContext函数，而不是 // // 直接使用本key。 // var userKey key // // // NewContext 返回保存了u的Context。 // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext 返回ctx中保存的User类型值。 // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key interface{}) interface{} } Context.Value的注意事项 Value仅用于存储和Context生命周期相关的数据，而不是用来传递可选参数的； 由此，Value里的值应该是设置后不应更改的； Value的key应该使用包内非导出的类型定义的非导出的全局变量，值的存取应该使用包提供的类型安全的函数而不是直接操纵Context.Value； Value中存在的值作为必不可少的参数时，为了高可读性，也不应该通过Context去获取，例如下方函数，即使uin和本次请求强绑定并存到了Context中，也应该显式地作为函数参数，例如func IsAdmin(ctx context.Context, uin string) (bool, error)。 Context.Value should inform, not control. –Jack Lindamood 树状Contexts 新创建的Context总是原有Context的子节点，并受原有Context的Deadline、cancel、Value影响。例如： func testWithTimeout() { a1 := context.Background() b2, cancelB2 := context.WithTimeout(a1, time.Minute) defer cancelB2() c3, cancelC3 := context.WithTimeout(b2, time.Hour) defer cancelC3() d3, cancelD3 := context.WithTimeout(b2, time.Second) defer cancelD3() e2, cancelE2 := context.WithCancel(a1) defer cancelE2() fmt.Println(a1.Deadline()) fmt.Println(b2.Deadline()) fmt.Println(c3.Deadline()) fmt.Println(d3.Deadline()) cancelB2() if err := d3.Err(); err != nil { fmt.Println(&quot;d3 is canceled:&quot;, err) } if err := e2.Err(); err == nil { fmt.Println(&quot;e2 is not canceled yet&quot;) } } /* 0001-01-01 00:00:00 false 2021-11-29 20:29:44.839665 m=+60.001770296 true 2021-11-29 20:29:44.839665 m=+60.001770296 true // 受父节点的1分钟超时影响，新设置1小时超时无效 2021-11-29 20:28:45.839691 m=+1.001796617 true // 新设置的1秒后超时 d3 is canceled: context canceled // 因为父节点被cancel e2 is not canceled yet // 不受非祖先节点的其他节点影响 */ 其他注意事项、总结 去看“太长不看版”。关于context源码的解读可见下一篇文章。</summary></entry><entry><title type="html">深入Go：错误的包装与解包</title><link href="http://localhost:4000/2021/08/16/%E6%B7%B1%E5%85%A5Go-%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%85%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%8C%85.html" rel="alternate" type="text/html" title="深入Go：错误的包装与解包" /><published>2021-08-16T00:00:00+00:00</published><updated>2021-08-16T00:00:00+00:00</updated><id>http://localhost:4000/2021/08/16/%E6%B7%B1%E5%85%A5Go:%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%85%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%8C%85</id><content type="html" xml:base="http://localhost:4000/2021/08/16/%E6%B7%B1%E5%85%A5Go-%E9%94%99%E8%AF%AF%E7%9A%84%E5%8C%85%E8%A3%85%E4%B8%8E%E8%A7%A3%E5%8C%85.html">&lt;p&gt;仔细想想，我们的Go代码中可能有四分之一的代码都是和错误处理相关的，而我们已经接受了，error无处不在。但似乎Golang的error处理并不够强大，也缺乏统一的错误处理流程的逻辑；在经历了大量的讨论后，Go 1.13引入了错误的包装和解包，也许某种程度上可以优化我们的错误处理流程。&lt;/p&gt;

&lt;h6 id=&quot;太长不看版&quot;&gt;太长不看版&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt;的作用有两点：一是让代码进入特定的错误处理流程，二是告诉程序员发生了什么状况&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt; interface只包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error() string&lt;/code&gt;这一方法，error难以仅仅通过字符串的匹配来完成上述两种角色&lt;/li&gt;
  &lt;li&gt;Go在1.13版本中引入了错误的包装与解包
    &lt;ul&gt;
      &lt;li&gt;仅需&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fmt.Errorf(&quot;...%w...&quot;, ..., err, ...)&lt;/code&gt;就可完成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt;的包装&lt;/li&gt;
      &lt;li&gt;可通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors.Is(err error, target error) bool&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors.As(err error, target interface{}) bool&lt;/code&gt;实现解包，作用分别是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt;是否包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;、是否包含可转换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;的错误&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在实践中，我们总是可以
    &lt;ul&gt;
      &lt;li&gt;包装error以便添加函数调用的上下文参数以便问题排查&lt;/li&gt;
      &lt;li&gt;在最终的栈底进行打印与解包，打印直接使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error() string&lt;/code&gt;方法，解包解析出需要的固定错误以作为API接口的响应返回&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（太长不看版结束）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;假设我们需要实现一个服务，对于管理员用户返回请求中ID所对应的数据，否则返回错误；该服务需要符合云API3.0的错误码规范，代码很简单：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HasPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uin&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getRole&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// logging uin&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apierr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewUnauthorizedOperationNoPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HasPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Uin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apierr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnauthorizedOperationNoPermission&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// new a Response with error message and return it&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// logging req and err, pack and return a Response&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们省略了查数据库并返回结果的逻辑。这只是一个简单的接口，只包含了两个步骤——鉴权和数据库查询——每一个步骤都可能有不同的错误：有的可能需要直接返回符合规范的云API 3.0错误码便于返回给请求方，有的可能需要打日志记录中间状态与参数以便我们调试。&lt;/p&gt;

&lt;p&gt;错误处理变得非常复杂，我们常常需要进行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err == SomeError&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err.Error() == SomeErrorString&lt;/code&gt;来进行比较，但这样做我们又很难把错误发生的上下文关联起来、问题排查变得困难。&lt;/p&gt;

&lt;p&gt;仅仅包含两个步骤的接口的错误处理就变得那么复杂，那么我们应该怎样重构我们Go代码的错误处理逻辑？&lt;/p&gt;

&lt;h2 id=&quot;error的角色&quot;&gt;error的角色&lt;/h2&gt;

&lt;p&gt;在解答上个问题前，我们需要回想，Golang的Error究竟要承担怎样的职责、在代码运行中应该扮演怎样的角色？&lt;/p&gt;

&lt;p&gt;实际上，error的角色分为：针对代码的和针对程序员的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对代码的：让代码进入特定的错误处理流程&lt;/li&gt;
  &lt;li&gt;针对程序员的：告诉程序员发生了什么状况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，error的处理应该面向这两点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对代码的：类型判断（错误是哪一种错误）&lt;/li&gt;
  &lt;li&gt;针对程序员的：打印字符串（把错误如何出现呈现出来）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt;就只是一个拥有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error() string&lt;/code&gt;的接口，如何实现error的双重角色？&lt;/p&gt;

&lt;h2 id=&quot;error的包装与解包&quot;&gt;error的包装与解包&lt;/h2&gt;

&lt;p&gt;Golang在1.13的release中引入了error的包装与解包，详见&lt;a href=&quot;https://blog.golang.org/go1.13-errors&quot;&gt;[Working with Errors in Go 1.13](https://blog.golang.org/go1.13-errors)&lt;/a&gt;。这里我们进行一个简单的语法介绍，然后在后文中详细说明如何实践。&lt;/p&gt;

&lt;h3 id=&quot;error的包装&quot;&gt;error的包装&lt;/h3&gt;

&lt;p&gt;举个例子，假设函数接收到了一个error，希望加入更多的上下文信息：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewOSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usingWindows&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewOSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Upgrading Windows. Sit back and relax.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usingWindows&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Send(%q): %w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I&apos;m using a Mac.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Send(&quot;I&apos;m using a Mac.&quot;): Upgrading Windows. Sit back and relax.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们单纯只是在调用fmt.Errorf的时候，把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%v&lt;/code&gt;换成了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%w&lt;/code&gt;，然后打印错误信息的时候，error自动调用了其&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Error() string&lt;/code&gt;方法。但之所以叫“error的包装”，是因为这样的方法得到的新error可以被解包。&lt;/p&gt;

&lt;h3 id=&quot;error的解包&quot;&gt;error的解包&lt;/h3&gt;

&lt;h4 id=&quot;errorsiserr-error-target-error-bool&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors.Is(err error, target error) bool&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors.Is(err error, target error) bool&lt;/code&gt;方法会解包所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt;里包装的error，如果里面有任何一个解包后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;== target&lt;/code&gt;，则返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;。例如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I&apos;m using a Mac.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Is&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usingWindows&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; Less than a minute remaining...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;//  Less than a minute remaining...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;errorsaserr-error-target-interface-bool&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errors.As(err error, target interface{}) bool&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;func As(err error, target interface{}) bool&lt;/code&gt;方法会解包所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;err&lt;/code&gt;里包装的error，并且看是否能类型转换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;的类型，如果可以，则将转换后的结果赋值到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;。例如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I&apos;m using a Mac.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;osError&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OSError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;osError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Got an OSError!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Got an OSError!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;error包装解包的实践&quot;&gt;error包装解包的实践&lt;/h2&gt;

&lt;p&gt;回到我们刚才的代码，我们的希望也就是对应于error的两个角色：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对代码的：接口能根据error最终能正确返回符合云API 3.0的Response&lt;/li&gt;
  &lt;li&gt;针对程序员的：能记录下调用链中的上下文并最终打印出来&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，原有代码可以这样设计：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HasPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uin&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 添加上下文信息&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HasPermission(%q): %w&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getRole&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apierr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewUnauthorizedOperationNoPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GetData(%q): %q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 打印错误信息&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apiError&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;APIError&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;As&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apiError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 解包错误并得到“可返回”的错误&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apiError&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ToError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 无法解包，使用默认的“可返回”的错误&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apierr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewFailedOperationError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HasPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Uin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retriveData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// return normally&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">仔细想想，我们的Go代码中可能有四分之一的代码都是和错误处理相关的，而我们已经接受了，error无处不在。但似乎Golang的error处理并不够强大，也缺乏统一的错误处理流程的逻辑；在经历了大量的讨论后，Go 1.13引入了错误的包装和解包，也许某种程度上可以优化我们的错误处理流程。 太长不看版 error的作用有两点：一是让代码进入特定的错误处理流程，二是告诉程序员发生了什么状况 error interface只包含了Error() string这一方法，error难以仅仅通过字符串的匹配来完成上述两种角色 Go在1.13版本中引入了错误的包装与解包 仅需fmt.Errorf(&quot;...%w...&quot;, ..., err, ...)就可完成error的包装 可通过errors.Is(err error, target error) bool和errors.As(err error, target interface{}) bool实现解包，作用分别是：error是否包含target、是否包含可转换为target的错误 在实践中，我们总是可以 包装error以便添加函数调用的上下文参数以便问题排查 在最终的栈底进行打印与解包，打印直接使用Error() string方法，解包解析出需要的固定错误以作为API接口的响应返回 （太长不看版结束） 假设我们需要实现一个服务，对于管理员用户返回请求中ID所对应的数据，否则返回错误；该服务需要符合云API3.0的错误码规范，代码很简单： func HasPermission(ctx context.Context, uin string) error { role, err := getRole(ctx, uin) if err != nil { // logging uin return err } if role != admin { return apierr.NewUnauthorizedOperationNoPermission() } return nil } func (s *Service) GetData(ctx context.Context, req *Request) (*Response, error) { if err := HasPermission(ctx, req.Uin); err != nil { if err == apierr.UnauthorizedOperationNoPermission { // new a Response with error message and return it } // logging req and err, pack and return a Response } } 这里我们省略了查数据库并返回结果的逻辑。这只是一个简单的接口，只包含了两个步骤——鉴权和数据库查询——每一个步骤都可能有不同的错误：有的可能需要直接返回符合规范的云API 3.0错误码便于返回给请求方，有的可能需要打日志记录中间状态与参数以便我们调试。 错误处理变得非常复杂，我们常常需要进行err == SomeError或者err.Error() == SomeErrorString来进行比较，但这样做我们又很难把错误发生的上下文关联起来、问题排查变得困难。 仅仅包含两个步骤的接口的错误处理就变得那么复杂，那么我们应该怎样重构我们Go代码的错误处理逻辑？ error的角色 在解答上个问题前，我们需要回想，Golang的Error究竟要承担怎样的职责、在代码运行中应该扮演怎样的角色？ 实际上，error的角色分为：针对代码的和针对程序员的。 针对代码的：让代码进入特定的错误处理流程 针对程序员的：告诉程序员发生了什么状况 所以，error的处理应该面向这两点： 针对代码的：类型判断（错误是哪一种错误） 针对程序员的：打印字符串（把错误如何出现呈现出来） 但是error就只是一个拥有Error() string的接口，如何实现error的双重角色？ error的包装与解包 Golang在1.13的release中引入了error的包装与解包，详见[Working with Errors in Go 1.13](https://blog.golang.org/go1.13-errors)。这里我们进行一个简单的语法介绍，然后在后文中详细说明如何实践。 error的包装 举个例子，假设函数接收到了一个error，希望加入更多的上下文信息： func NewOSError(msg string) error { return &amp;amp;OSError{msg} } var usingWindows = NewOSError(&quot;Upgrading Windows. Sit back and relax.&quot;) func send(message string) error { return usingWindows } func Send(message string) error { err := send(message) if err != nil { e := fmt.Errorf(&quot;Send(%q): %w&quot;, message, err) return e } return nil } func main() { err := Send(&quot;I&apos;m using a Mac.&quot;) if err != nil { println(err.Error()) } } // Send(&quot;I&apos;m using a Mac.&quot;): Upgrading Windows. Sit back and relax. 我们单纯只是在调用fmt.Errorf的时候，把%v换成了%w，然后打印错误信息的时候，error自动调用了其Error() string方法。但之所以叫“error的包装”，是因为这样的方法得到的新error可以被解包。 error的解包 errors.Is(err error, target error) bool errors.Is(err error, target error) bool方法会解包所有err里包装的error，如果里面有任何一个解包后== target，则返回true。例如： func main() { err := Send(&quot;I&apos;m using a Mac.&quot;) if err != nil { if errors.Is(err, usingWindows) { println(&quot; Less than a minute remaining...&quot;) } else { println(err.Error()) } } } //  Less than a minute remaining... errors.As(err error, target interface{}) bool func As(err error, target interface{}) bool方法会解包所有err里包装的error，并且看是否能类型转换为target的类型，如果可以，则将转换后的结果赋值到target。例如： func main() { err := Send(&quot;I&apos;m using a Mac.&quot;) if err != nil { var osError *OSError if errors.As(err, &amp;amp;osError) { println(&quot;Got an OSError!&quot;) } else { println(err.Error()) } } } // Got an OSError! error包装解包的实践 回到我们刚才的代码，我们的希望也就是对应于error的两个角色： 针对代码的：接口能根据error最终能正确返回符合云API 3.0的Response 针对程序员的：能记录下调用链中的上下文并最终打印出来 因此，原有代码可以这样设计： func HasPermission(ctx context.Context, uin string) error { var err error defer func() { // 添加上下文信息 if err != nil { err = fmt.Errorf(&quot;HasPermission(%q): %w&quot;, uin, err) } }() role, err := getRole(ctx, uin) if err != nil { return err } if role != admin { return apierr.NewUnauthorizedOperationNoPermission() } return nil } func (s *Service) GetData(ctx context.Context, req *Request) (*Response, error) { var err error handler := func(e error) (*Response, error) { log.Errorf(&quot;GetData(%q): %q&quot;, req, e.Error()) // 打印错误信息 r := &amp;amp;Response{} var apiError *APIError if errors.As(e, &amp;amp;apiError) { // 解包错误并得到“可返回”的错误 r.Error = apiError.ToError() } else { // 无法解包，使用默认的“可返回”的错误 r.Error = apierr.NewFailedOperationError(e) } } if err := HasPermission(ctx, req.Uin); err != nil { return handler(err) } data, err := retriveData(ctx, req.Key) if err != nil { return handler(err) } // return normally }</summary></entry><entry><title type="html">深入Go：Internationalization-国际化</title><link href="http://localhost:4000/2021/05/11/%E6%B7%B1%E5%85%A5Go-Internationalization-%E5%9B%BD%E9%99%85%E5%8C%96.html" rel="alternate" type="text/html" title="深入Go：Internationalization-国际化" /><published>2021-05-11T00:00:00+00:00</published><updated>2021-05-11T00:00:00+00:00</updated><id>http://localhost:4000/2021/05/11/%E6%B7%B1%E5%85%A5Go:Internationalization-%E5%9B%BD%E9%99%85%E5%8C%96</id><content type="html" xml:base="http://localhost:4000/2021/05/11/%E6%B7%B1%E5%85%A5Go-Internationalization-%E5%9B%BD%E9%99%85%E5%8C%96.html">&lt;p&gt;当服务需要应对多语言场景时，我们应该如何组织代码？&lt;/p&gt;

&lt;h6 id=&quot;说明&quot;&gt;说明&lt;/h6&gt;

&lt;p&gt;本文不探讨诸如单复数变换等复杂情况，如有需要，请参见&lt;a href=&quot;https://phrase.com/blog/posts/internationalization-i18n-go/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h6 id=&quot;太长不看版&quot;&gt;（太长不看版）&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;读取语言标签与相应翻译，进行翻译字符串的注册&lt;/li&gt;
  &lt;li&gt;获取时根据语言解析标签并获得相应语言的Printer，根据Key进行翻译字符串的查找与生成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;golang.org/x/text/language&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;golang.org/x/text/message&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 此处`und`为undefined，用于语言无对应的翻译时的显示&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 请根据翻译文件准备好相应的key与翻译字符串&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zh&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;你好，%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;und&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HelloString&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// key是字典用于查找翻译字符串的键；当然这里也可以使用&quot;Hello, %s&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;translation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 根据语言字符串解析语言标签&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// 语言注册建议在程序初始化阶段完成，此时出错可能直接panic较好&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 根据语言tag、key与翻译字符串进行设置&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;translation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lang&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 指定解析出错时希望返回的语言&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Und&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 根据语言获取Printer&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewPrinter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en-US&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en-US&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// zh-CN 和 zh-SG 的 parent 都是 zh，因此会根据 zh 进行返回&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zh-CN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zh-CN&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zh-SG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zh-SG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// zh-TW 的 parent 并不是 zh，因此会根据 und tag 返回相应的翻译&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zh-TW&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zh-TW&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 解析语言出错时的处理&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getTranslation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;???&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;???&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/* 输出：
Hello, en
Hello, en-US
你好，zh
你好，zh-CN
你好，zh-SG
Hello, zh-TW
Hello, ???
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;太长不看版结束&quot;&gt;（太长不看版结束）&lt;/h6&gt;

&lt;h2 id=&quot;prerequisites-原理&quot;&gt;Prerequisites: 原理&lt;/h2&gt;

&lt;h3 id=&quot;语言标签&quot;&gt;语言标签&lt;/h3&gt;

&lt;p&gt;我们通常可以在HTTP header里看见类似于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept-Language: zh-CN&lt;/code&gt;或是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept-Language: en&lt;/code&gt;之类的值，这里header里对应的值就是&lt;strong&gt;语言标签&lt;/strong&gt;。类似地，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh-cmn-Hans-CN&lt;/code&gt;也是语言标签。&lt;/p&gt;

&lt;h4 id=&quot;语言标签的语法&quot;&gt;语言标签的语法&lt;/h4&gt;

&lt;p&gt;我们需要关注的语言标签的语法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;主语言子标签&lt;/code&gt;-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;扩展语言子标签&lt;/code&gt;-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;文字子标签&lt;/code&gt;-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;地区子标签&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh-cmn-Hans-CN&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了主语言子标签是必填，其他都是可选；&lt;/li&gt;
  &lt;li&gt;扩展语言子标签为3字母，最多可有三个；&lt;/li&gt;
  &lt;li&gt;文字子标签为4字母（首字母大写），最多一个；&lt;/li&gt;
  &lt;li&gt;地区子标签为2字母（通常大写）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh-cmn-Hans-CN&lt;/code&gt;被解读为：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;汉语(zhongwen)-普通话(simplified mandarin)-简体(Han Simplified)-中国大陆&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外，该语言标签在2009年后就不再被推荐使用了，因为扩展语言标签&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmn&lt;/code&gt;蕴含该语言是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh&lt;/code&gt;（汉语）。当然，目前&lt;strong&gt;为了兼容，建议使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh&lt;/code&gt;而非&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmn&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;go存储翻译字符串&quot;&gt;Go存储翻译字符串&lt;/h3&gt;

&lt;p&gt;Go通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message.SetString(tag language.Tag, key string, msg string)&lt;/code&gt;来存储翻译字符串；其中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag&lt;/code&gt;为语言标签，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;为该字符串的键，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt;为该字符串在该语言下的值。例如&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// tag: en&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;English&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HelloString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// tag: zh-Hans&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SimplifiedChinese&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HelloString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;你好，%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;c&quot;&gt;// tag: und&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Und&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HelloString&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hi, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;go获取翻译字符串&quot;&gt;Go获取翻译字符串&lt;/h3&gt;

&lt;p&gt;Go通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message.NewPrinter(tag language.Tag)&lt;/code&gt;来获取翻译字符串字典，通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printer.Sprintf(key string, content ...interface{})&lt;/code&gt;（或其他类似于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fmt&lt;/code&gt;中的方法）来生成（或打印）翻译字符串。下文我们统一使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sprintf&lt;/code&gt;作为示例。&lt;/p&gt;

&lt;p&gt;打印的时候，使用key并根据语言标签查找相应的字典，如果在该语言标签中找不到该key，则依次在其祖先节点中继续查找；如果找到根节点（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;und&lt;/code&gt;）仍未找到，则效果同直接调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fmt.Sprintf&lt;/code&gt;相同。因此，在简单场景下，&lt;strong&gt;建议直接在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;en&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;und&lt;/code&gt;下增加翻译语句&lt;/strong&gt;；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;und&lt;/code&gt;用于处理无法解析的语言标签（例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;???&lt;/code&gt;）或意料之外的语言标签（例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh-TW&lt;/code&gt;的祖先节点依次为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zh-Hant&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;und&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewPrinter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;English&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Hello, en&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewPrinter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AmericanEnglish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;en-US&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//* Hello, en-US&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewPrinter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Chinese&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//** Hi, zh&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewPrinter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;language&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SimplifiedChinese&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zh-Hans&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 你好，zh-Hans&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/*
*   这里，因为en-US的父节点为en，因此可以找到对应翻译字符串
**  这里，因为zh的父节点是und，因此找到了und内的翻译字符串（zh-Hans是zh的子节点）
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;

&lt;h3 id=&quot;step-1-准备字典&quot;&gt;Step 1: 准备字典&lt;/h3&gt;

&lt;p&gt;建议将各语言的翻译字符串与语言标签准备在单独的文本文件里，通过读取文件、解析标签与字符串，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message.SetString&lt;/code&gt;设置。&lt;/p&gt;

&lt;h3 id=&quot;step-2-根据传入的语言标签获取翻译字符串&quot;&gt;Step 2: 根据传入的语言标签获取翻译字符串&lt;/h3&gt;

&lt;p&gt;根据语言标签调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;language.Parse&lt;/code&gt;获取tag，使用该tag获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message.Printer&lt;/code&gt;，使用该printer根据key调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printer.Sprintf()&lt;/code&gt;生成翻译字符串。&lt;/p&gt;

&lt;h4 id=&quot;grpc-gateway获取请求中的语言标签&quot;&gt;gRPC Gateway获取请求中的语言标签&lt;/h4&gt;

&lt;p&gt;gRPC Gateway会将HTTP headers存储在context中，调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;metadata.FromIncomingContext(ctx context.Context)&lt;/code&gt;可获取到。&lt;/p&gt;

&lt;p&gt;注意，获取到的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[string][]string&lt;/code&gt;的结构，map的键为HTTP headers的各名称，因此可能是全小写（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accept-language&lt;/code&gt;）也可能是首字母大写（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept-Language&lt;/code&gt;），因此需要使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strings.EqualFold(k, &quot;accept-language&quot;)&lt;/code&gt;来忽略大小写地比较。&lt;/p&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">当服务需要应对多语言场景时，我们应该如何组织代码？ 说明 本文不探讨诸如单复数变换等复杂情况，如有需要，请参见这里。 （太长不看版） 读取语言标签与相应翻译，进行翻译字符串的注册 获取时根据语言解析标签并获得相应语言的Printer，根据Key进行翻译字符串的查找与生成 示例代码如下： package main import ( &quot;golang.org/x/text/language&quot; &quot;golang.org/x/text/message&quot; ) // 此处`und`为undefined，用于语言无对应的翻译时的显示 // 请根据翻译文件准备好相应的key与翻译字符串 var msg = map[string]string{&quot;zh&quot;: &quot;你好，%s&quot;, &quot;en&quot;: &quot;Hello, %s&quot;, &quot;und&quot;: &quot;Hello, %s&quot;} var key = &quot;HelloString&quot; // key是字典用于查找翻译字符串的键；当然这里也可以使用&quot;Hello, %s&quot; func register(k string, d map[string]string) { for lang, translation := range d { // 根据语言字符串解析语言标签 tag, err := language.Parse(lang) if err != nil { // 语言注册建议在程序初始化阶段完成，此时出错可能直接panic较好 panic(err) } // 根据语言tag、key与翻译字符串进行设置 err = message.SetString(tag, key, translation) if err != nil { panic(err) } } } func getTranslation(k, lang string, content []interface{}) string { tag, err := language.Parse(lang) if err != nil { // 指定解析出错时希望返回的语言 tag = language.Und } // 根据语言获取Printer p := message.NewPrinter(tag) return p.Sprintf(k, content...) } func main() { register(key, msg) println(getTranslation(key, &quot;en&quot;, []interface{}{&quot;en&quot;})) println(getTranslation(key, &quot;en-US&quot;, []interface{}{&quot;en-US&quot;})) println(getTranslation(key, &quot;zh&quot;, []interface{}{&quot;zh&quot;})) // zh-CN 和 zh-SG 的 parent 都是 zh，因此会根据 zh 进行返回 println(getTranslation(key, &quot;zh-CN&quot;, []interface{}{&quot;zh-CN&quot;})) println(getTranslation(key, &quot;zh-SG&quot;, []interface{}{&quot;zh-SG&quot;})) // zh-TW 的 parent 并不是 zh，因此会根据 und tag 返回相应的翻译 println(getTranslation(key, &quot;zh-TW&quot;, []interface{}{&quot;zh-TW&quot;})) // 解析语言出错时的处理 println(getTranslation(key, &quot;???&quot;, []interface{}{&quot;???&quot;})) } /* 输出： Hello, en Hello, en-US 你好，zh 你好，zh-CN 你好，zh-SG Hello, zh-TW Hello, ??? */ （太长不看版结束） Prerequisites: 原理 语言标签 我们通常可以在HTTP header里看见类似于Accept-Language: zh-CN或是Accept-Language: en之类的值，这里header里对应的值就是语言标签。类似地，zh-cmn-Hans-CN也是语言标签。 语言标签的语法 我们需要关注的语言标签的语法： 主语言子标签-扩展语言子标签-文字子标签-地区子标签 zh-cmn-Hans-CN 除了主语言子标签是必填，其他都是可选； 扩展语言子标签为3字母，最多可有三个； 文字子标签为4字母（首字母大写），最多一个； 地区子标签为2字母（通常大写） 因此，zh-cmn-Hans-CN被解读为： 汉语(zhongwen)-普通话(simplified mandarin)-简体(Han Simplified)-中国大陆 另外，该语言标签在2009年后就不再被推荐使用了，因为扩展语言标签cmn蕴含该语言是zh（汉语）。当然，目前为了兼容，建议使用zh而非cmn。 Go存储翻译字符串 Go通过调用message.SetString(tag language.Tag, key string, msg string)来存储翻译字符串；其中，tag为语言标签，key为该字符串的键，msg为该字符串在该语言下的值。例如 // tag: en message.SetString(language.English, &quot;HelloString&quot;, &quot;Hello, %s&quot;) // tag: zh-Hans message.SetString(language.SimplifiedChinese, &quot;HelloString&quot;, &quot;你好，%s&quot;) // tag: und message.SetString(language.Und, &quot;HelloString&quot;, &quot;Hi, %s&quot;) Go获取翻译字符串 Go通过调用message.NewPrinter(tag language.Tag)来获取翻译字符串字典，通过调用printer.Sprintf(key string, content ...interface{})（或其他类似于fmt中的方法）来生成（或打印）翻译字符串。下文我们统一使用Sprintf作为示例。 打印的时候，使用key并根据语言标签查找相应的字典，如果在该语言标签中找不到该key，则依次在其祖先节点中继续查找；如果找到根节点（und）仍未找到，则效果同直接调用fmt.Sprintf相同。因此，在简单场景下，建议直接在en、zh和und下增加翻译语句；und用于处理无法解析的语言标签（例如，???）或意料之外的语言标签（例如，zh-TW的祖先节点依次为zh-Hant、und）。 例如 message.NewPrinter(language.English, &quot;en&quot;) // Hello, en message.NewPrinter(language.AmericanEnglish, &quot;en-US&quot;) //* Hello, en-US message.NewPrinter(language.Chinese, &quot;zh&quot;) //** Hi, zh message.NewPrinter(language.SimplifiedChinese, &quot;zh-Hans&quot;) // 你好，zh-Hans /* * 这里，因为en-US的父节点为en，因此可以找到对应翻译字符串 ** 这里，因为zh的父节点是und，因此找到了und内的翻译字符串（zh-Hans是zh的子节点） */ 实践 Step 1: 准备字典 建议将各语言的翻译字符串与语言标签准备在单独的文本文件里，通过读取文件、解析标签与字符串，调用message.SetString设置。 Step 2: 根据传入的语言标签获取翻译字符串 根据语言标签调用language.Parse获取tag，使用该tag获取message.Printer，使用该printer根据key调用printer.Sprintf()生成翻译字符串。 gRPC Gateway获取请求中的语言标签 gRPC Gateway会将HTTP headers存储在context中，调用metadata.FromIncomingContext(ctx context.Context)可获取到。 注意，获取到的是map[string][]string的结构，map的键为HTTP headers的各名称，因此可能是全小写（accept-language）也可能是首字母大写（Accept-Language），因此需要使用strings.EqualFold(k, &quot;accept-language&quot;)来忽略大小写地比较。</summary></entry><entry><title type="html">深入Go：并发迷思-消失的赋值语句</title><link href="http://localhost:4000/2021/03/12/%E6%B7%B1%E5%85%A5Go-%E5%B9%B6%E5%8F%91%E8%BF%B7%E6%80%9D-%E6%B6%88%E5%A4%B1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5.html" rel="alternate" type="text/html" title="深入Go：并发迷思-消失的赋值语句" /><published>2021-03-12T00:00:00+00:00</published><updated>2021-03-12T00:00:00+00:00</updated><id>http://localhost:4000/2021/03/12/%E6%B7%B1%E5%85%A5Go:%E5%B9%B6%E5%8F%91%E8%BF%B7%E6%80%9D-%E6%B6%88%E5%A4%B1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5</id><content type="html" xml:base="http://localhost:4000/2021/03/12/%E6%B7%B1%E5%85%A5Go-%E5%B9%B6%E5%8F%91%E8%BF%B7%E6%80%9D-%E6%B6%88%E5%A4%B1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5.html">&lt;p&gt;对全局变量的赋值，为何无缘无故消失？等候了千万个时钟周期的打印语句，为何发现变量没有一丝改变？意料之外的结果，却为何又是在情理之中？这究竟是编译器的背叛，还是随机的巧合——本篇文章将带您深入Go内存模型，一起走近并发。&lt;/p&gt;

&lt;h3 id=&quot;热身&quot;&gt;热身&lt;/h3&gt;

&lt;p&gt;先看一个&lt;a href=&quot;http://preshing.com/20120515/memory-reordering-caught-in-the-act/&quot;&gt;经典的问题&lt;/a&gt;，下列代码输出的结果可能是多少？&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// goroutine A&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// line A1&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// line A2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// goroutine B&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// line B1&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// line B2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出当然可能是1，执行顺序可能是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A1: y = 1                    | B1: x = 1
A2: r1 = x // 0        | B2: r2 = y // 0
B1: x = 1                    | A1: y = 1
B2: r2 = y // 1        | A2: r1 = x // 1
------------- 1     | ------------- 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出也可能是2，因为执行顺序可能是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A1: y = 1
B1: x = 1
-- then --
A2: r1 = x // 1
B2: r2 = y // 1
------------ 2 --
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是运行10000000次，有9994463次结果为1，有23次结果为2，有5514次结果为0！&lt;/p&gt;

&lt;p&gt;为什么结果为0，也就是执行顺序可能变成了：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A2: r1 = x
B2: r2 = y
A1: y = 1
B1: x = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上，CPU的指令执行顺序是乱序执行的，因为但就一个协程执行的代码而言，两行语句是无关的，CPU完全可能会乱序执行；指令乱序执行也是现代CPU能运行如此之快的原因之一——否则，如果一个store指令需要等待写入，后面的load指令只能白白等待。&lt;/p&gt;

&lt;p&gt;（也许不仅仅因为CPU的指令乱序导致迷思，后面我们可以看到。）&lt;/p&gt;

&lt;h3 id=&quot;意料之外的迷思&quot;&gt;意料之外的迷思&lt;/h3&gt;

&lt;p&gt;再看另一段代码，请问输出应该是什么？&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;答案是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isRunning: 1, count: 0&lt;/code&gt;，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fg1&lt;/code&gt;中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isRunning--&lt;/code&gt;没有被执行，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fg2&lt;/code&gt;根本没有返回。&lt;/p&gt;

&lt;p&gt;这就很让人意外，足足等了3秒的时间，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fg1&lt;/code&gt;里的循环完全没有产生任何的效果。实际上，查看go汇编代码（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go tool compile -S file.go &amp;gt; file.s&lt;/code&gt;），可以发现如下结果：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;.fg1 STEXT nosplit size=3 args=0x0 locals=0x0
  ...
  // swap the value of $(AX) and $(AX) atomically, or NOP -- do nothing
    0x0000 00000 (pkg/main/file.go:10)    XCHGL    AX, AX 
    // jump to last line
    0x0001 00001 (pkg/main/file.go:1)    JMP    0        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fg1&lt;/code&gt;什么都没有做，不说等3秒了，等10年也没用！那，是不是Go的编译器背叛了这段代码？&lt;/p&gt;

&lt;h3 id=&quot;情理之中的解答&quot;&gt;情理之中的解答&lt;/h3&gt;

&lt;p&gt;最后再问一个问题，在Go当中，对一个变量的write在什么情况下才能保证被对该变量的read所感知到？虽然你可能有Go的编程经验，但很可能你也说不清楚这个问题。它实际上有&lt;a href=&quot;https://golang.org/ref/mem&quot;&gt;官方的解答&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们一边举例子，一边来解释。&lt;/p&gt;

&lt;h4 id=&quot;早于晚于并发于&quot;&gt;早于、晚于、并发于&lt;/h4&gt;

&lt;p&gt;首先我们要定义偏序关系（回想大学知识，偏序关系是非自反、反对称、传递的关系）“早于”（&lt;em&gt;Happens Before&lt;/em&gt;）。为方便起见，我们记“A早于B”为$A&amp;lt;B$；我们也定义“晚于”关系（&lt;em&gt;Happens After&lt;/em&gt;），“B晚于A”记为$B&amp;gt;A$——如果$A&amp;lt;B$，则有$B &amp;gt; A$。如果$A &amp;lt; B$ 、$A &amp;gt; B$都不成立，则称“A并发于B”。&lt;/p&gt;

&lt;p&gt;首先，单个goroutine中顺序执行的语句，在先的与在后的形成“早于”关系，例如下方代码中，$A_1 &amp;lt; A_2$：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A_1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A_2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其次，包的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt;、goroutine的创建、channel交互、锁、once也定义了偏序关系；这里，我们选相关的goroutine创建、销毁与锁的使用进行介绍。&lt;/p&gt;

&lt;h5 id=&quot;goroutine的创建&quot;&gt;Goroutine的创建&lt;/h5&gt;

&lt;p&gt;创建goroutine的代码一定早于该goroutine中代码的执行。例如下面的代码中，由上面的规则有$A &amp;lt; B$，由本条规则有$B &amp;lt; C$，由关系的传递性，有$A &amp;lt; C$；如果没有其他协程对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x, y&lt;/code&gt;的write的话，一定有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y = 1&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// B&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// C&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;锁&quot;&gt;锁&lt;/h5&gt;

&lt;p&gt;对于任意&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Mutex&lt;/code&gt;变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;和$n &amp;lt; m \in \mathbb N$，第$n$次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l.Unlock()&lt;/code&gt;的调用早于第$m$次调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l.Lock()&lt;/code&gt;返回，例如以下代码中，我们根据本规则有：$V &amp;lt; C$。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// U&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// V&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// B&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// C&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//D&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，我们有：$A &amp;lt; B &amp;lt; U &amp;lt; V$，$V &amp;lt; C &amp;lt; D$，故：$A &amp;lt; B &amp;lt; U &amp;lt; V &amp;lt; C &amp;lt; D$。也就是说，如果没有其他线程修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;，我们一定可以打印出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello world&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt;有类似情况，不再赘述。&lt;/p&gt;

&lt;h4 id=&quot;保证write能被read观察到的条件&quot;&gt;保证write能被read观察到的条件&lt;/h4&gt;

&lt;p&gt;回到第三个问题，对变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;的write $w$如何才能保证被read $r$观察到，&lt;a href=&quot;https://golang.org/ref/mem&quot;&gt;Go内存模型&lt;/a&gt;规定了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$w &amp;lt; r$；且&lt;/li&gt;
  &lt;li&gt;其他对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;的写要么早于$w$，要么晚于$r$。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;注意&quot;&gt;注意&lt;/h5&gt;

&lt;p&gt;Go内存模型也说明了：&lt;/p&gt;

&lt;p&gt;一，Goroutine代码的执行、销毁时间没有任何保证，甚至下方的代码行$A$可以被编译器直接删除：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;二，如果read $r$观察到了并发于$r$的write $w$，也不能保证任何晚于$r$的read能观察到任何早于$w$的write——这是因为$r$观察到$w$不能推出$r$晚于$w$。&lt;/p&gt;

&lt;p&gt;举个例子，下方代码中，我们只能得到$C &amp;lt; D &amp;lt; E$和$C &amp;lt; A &amp;lt; B$，并不能得出$A &amp;lt; E$；因此即使偶然有循环$D$退出，也不能保证能打印出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// B&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// C&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// D&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// E&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;解答&quot;&gt;解答&lt;/h4&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// B&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// C&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// D&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// E&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以得出：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$C &amp;lt; A$&lt;/li&gt;
  &lt;li&gt;$D &amp;lt; B$&lt;/li&gt;
  &lt;li&gt;$C &amp;lt; E$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但我们不能得到$A$和$B$、$A$和$E$之间的早于关系。因此，编译器完全可以优化掉&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fg1&lt;/code&gt;中的赋值语句。详细讨论还可以见&lt;a href=&quot;http://mk.woa.com/q/269855&quot;&gt;码客&lt;/a&gt;与&lt;a href=&quot;https://groups.google.com/g/golang-nuts/c/eT9vsOORTsA&quot;&gt;Google Groups - golang-nuts&lt;/a&gt;（至于为什么编译器在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;short circuit&lt;/code&gt;阶段优化掉该赋值，尚在讨论之中，后续会继续更新）。&lt;/p&gt;

&lt;h3 id=&quot;讨论&quot;&gt;讨论&lt;/h3&gt;

&lt;p&gt;再来看一段代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码究竟有没有问题？&lt;/p&gt;

&lt;p&gt;运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go run -race&lt;/code&gt;来查看data race的情况，马上会得到在$A$处会有一个协程写一个协程读的情况，我们之前的做法都是，把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasLoad&lt;/code&gt;的读写都使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync/atomic&lt;/code&gt;包进行操作。但真的需要吗？&lt;/p&gt;

&lt;h4 id=&quot;go-memory-model-advice&quot;&gt;Go Memory Model: Advice&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.&lt;/p&gt;

  &lt;p&gt;To serialize access, protect the data with channel operations or other synchronization primitives such as those in the &lt;a href=&quot;https://golang.org/pkg/sync/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://golang.org/pkg/sync/atomic/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync/atomic&lt;/code&gt;&lt;/a&gt; packages.&lt;/p&gt;

  &lt;p&gt;If you must read the rest of this document to understand the behavior of your program, you are being too clever.&lt;/p&gt;

  &lt;p&gt;Don’t be clever.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;被多个goroutines并发读写数据的程序必须串行化这样的读写。&lt;/p&gt;

  &lt;p&gt;为此，请使用channel操作或其他例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync/atomic&lt;/code&gt;中的同步原语保护该类数据。&lt;/p&gt;

  &lt;p&gt;如果你一定要阅读本文（笔者注：即Go Memory Model）剩余部分以理解你程序的行为，那么你就是耍小聪明了。&lt;/p&gt;

  &lt;p&gt;别耍小聪明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;遇到并发读写变量的情况，请一定使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutex&lt;/code&gt;或atomic操作；我们可以认为这段代码是存在问题的。&lt;/p&gt;

&lt;h4 id=&quot;可以跳过的小聪明分析&quot;&gt;可以跳过的小聪明分析&lt;/h4&gt;

&lt;p&gt;其实这段代码严格意义上是没有问题的，我们再来分析（为方便起见，我们假设只有2个协程访问&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance&lt;/code&gt;，所以我们可以把它分别命名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance1&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance2&lt;/code&gt;）：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getInstance1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 和getInstance完全相同&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// B1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// C1&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// D1&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// E1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// F1&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getInstance2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 和getInstance完全相同&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// A2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// B2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// C2&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// D2&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;hasLoad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// E2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// F2&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getInstance1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getInstance2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们假设$B_2 &amp;gt; F_1$，也就是说&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance1&lt;/code&gt;先调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m.Lock()&lt;/code&gt;并最终&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m.Unlock()&lt;/code&gt;，然后才是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance2&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m.Lock()&lt;/code&gt;返回（对称地可以分析另一情况，因此不再赘述）。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance1&lt;/code&gt;中，因为是串行执行，有$D_1 &amp;lt; E_1 &amp;lt; F_1$。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance2&lt;/code&gt;中，也是因为串行执行，有$B_2 &amp;lt; C_2$。&lt;/p&gt;

&lt;p&gt;所以由假设$B_2 &amp;gt; F_1$，有$D_1 &amp;lt; E_1 &amp;lt; F_1 &amp;lt; B_2 &amp;lt; C_2$，由于对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasLoad&lt;/code&gt;没有其他的写，根据保证，可以知道$E_1$中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasLoad = 1&lt;/code&gt;可以被$C_2$中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if hasLoad == 0&lt;/code&gt;观察到，因此不会进入$D_2$、$E_2$，不会导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instance&lt;/code&gt;被多次赋值——代码是正确的。而$A_1$、$A_2$和$E_1$、$E_2$的data race其实无关紧要，因为有$C_1$、$C_2$处的双重校验，第一次&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m.Unlock()&lt;/code&gt;之前的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasLoad = 1&lt;/code&gt;被观察到了。&lt;/p&gt;

&lt;p&gt;实际上可以运行以上代码，每次用多个协程调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInstance&lt;/code&gt;，重复1000000次，没有一次有发生&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instance&lt;/code&gt;重复赋值。&lt;/p&gt;

&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;并发中意料之外的结果，总是有着情理之中的解释；&lt;/li&gt;
  &lt;li&gt;虽然仔细地分析可以得到结论，但还是请合理使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutex&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt;操作。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">对全局变量的赋值，为何无缘无故消失？等候了千万个时钟周期的打印语句，为何发现变量没有一丝改变？意料之外的结果，却为何又是在情理之中？这究竟是编译器的背叛，还是随机的巧合——本篇文章将带您深入Go内存模型，一起走近并发。 热身 先看一个经典的问题，下列代码输出的结果可能是多少？ wg := sync.WaitGroup{} x, y, r1, r2 := 0, 0, 0, 0 wg.Add(2) go func() { // goroutine A y = 1 // line A1 r1 = x // line A2 wg.Done() }() go func() { // goroutine B x = 1 // line B1 r2 = y // line B2 wg.Done() } fmt.Println(r1 + r2) 输出当然可能是1，执行顺序可能是： A1: y = 1 | B1: x = 1 A2: r1 = x // 0 | B2: r2 = y // 0 B1: x = 1 | A1: y = 1 B2: r2 = y // 1 | A2: r1 = x // 1 ------------- 1 | ------------- 1 输出也可能是2，因为执行顺序可能是： A1: y = 1 B1: x = 1 -- then -- A2: r1 = x // 1 B2: r2 = y // 1 ------------ 2 -- 但是运行10000000次，有9994463次结果为1，有23次结果为2，有5514次结果为0！ 为什么结果为0，也就是执行顺序可能变成了： A2: r1 = x B2: r2 = y A1: y = 1 B1: x = 1 实际上，CPU的指令执行顺序是乱序执行的，因为但就一个协程执行的代码而言，两行语句是无关的，CPU完全可能会乱序执行；指令乱序执行也是现代CPU能运行如此之快的原因之一——否则，如果一个store指令需要等待写入，后面的load指令只能白白等待。 （也许不仅仅因为CPU的指令乱序导致迷思，后面我们可以看到。） 意料之外的迷思 再看另一段代码，请问输出应该是什么？ var isRunning = int32(1) func fg1() { for { isRunning-- } } func fg2() int { count := 1 for isRunning &amp;gt; 0 { count++ } return count } func main() { count := 0 go fg1() go func() { count = fg2() }() time.Sleep(3 * time.Second) println(isRunning) println(count) } 答案是：isRunning: 1, count: 0，也就是fg1中的isRunning--没有被执行，fg2根本没有返回。 这就很让人意外，足足等了3秒的时间，而fg1里的循环完全没有产生任何的效果。实际上，查看go汇编代码（go tool compile -S file.go &amp;gt; file.s），可以发现如下结果： &quot;&quot;.fg1 STEXT nosplit size=3 args=0x0 locals=0x0 ... // swap the value of $(AX) and $(AX) atomically, or NOP -- do nothing 0x0000 00000 (pkg/main/file.go:10) XCHGL AX, AX // jump to last line 0x0001 00001 (pkg/main/file.go:1) JMP 0 即，fg1什么都没有做，不说等3秒了，等10年也没用！那，是不是Go的编译器背叛了这段代码？ 情理之中的解答 最后再问一个问题，在Go当中，对一个变量的write在什么情况下才能保证被对该变量的read所感知到？虽然你可能有Go的编程经验，但很可能你也说不清楚这个问题。它实际上有官方的解答。 我们一边举例子，一边来解释。 早于、晚于、并发于 首先我们要定义偏序关系（回想大学知识，偏序关系是非自反、反对称、传递的关系）“早于”（Happens Before）。为方便起见，我们记“A早于B”为$A&amp;lt;B$；我们也定义“晚于”关系（Happens After），“B晚于A”记为$B&amp;gt;A$——如果$A&amp;lt;B$，则有$B &amp;gt; A$。如果$A &amp;lt; B$ 、$A &amp;gt; B$都不成立，则称“A并发于B”。 首先，单个goroutine中顺序执行的语句，在先的与在后的形成“早于”关系，例如下方代码中，$A_1 &amp;lt; A_2$： func f1() { y = 1 // A_1 r1 = x // A_2 } 其次，包的init、goroutine的创建、channel交互、锁、once也定义了偏序关系；这里，我们选相关的goroutine创建、销毁与锁的使用进行介绍。 Goroutine的创建 创建goroutine的代码一定早于该goroutine中代码的执行。例如下面的代码中，由上面的规则有$A &amp;lt; B$，由本条规则有$B &amp;lt; C$，由关系的传递性，有$A &amp;lt; C$；如果没有其他协程对x, y的write的话，一定有y = 1。 x = 1 // A go func() { // B y = x // C }() 锁 对于任意sync.Mutex变量l和$n &amp;lt; m \in \mathbb N$，第$n$次l.Unlock()的调用早于第$m$次调用l.Lock()返回，例如以下代码中，我们根据本规则有：$V &amp;lt; C$。 var l sync.Mutex var a string func f() { a = &quot;hello world&quot; // U l.Unlock() // V } func main() { l.Lock() // A go f() // B l.Lock() // C print(a) //D } 因此，我们有：$A &amp;lt; B &amp;lt; U &amp;lt; V$，$V &amp;lt; C &amp;lt; D$，故：$A &amp;lt; B &amp;lt; U &amp;lt; V &amp;lt; C &amp;lt; D$。也就是说，如果没有其他线程修改a，我们一定可以打印出hello world。 sync.RWMutex有类似情况，不再赘述。 保证write能被read观察到的条件 回到第三个问题，对变量x的write $w$如何才能保证被read $r$观察到，Go内存模型规定了： $w &amp;lt; r$；且 其他对于x的写要么早于$w$，要么晚于$r$。 注意 Go内存模型也说明了： 一，Goroutine代码的执行、销毁时间没有任何保证，甚至下方的代码行$A$可以被编译器直接删除： var a string func hello() { go func() { a = &quot;hello&quot; }() // A print(a) } 二，如果read $r$观察到了并发于$r$的write $w$，也不能保证任何晚于$r$的read能观察到任何早于$w$的write——这是因为$r$观察到$w$不能推出$r$晚于$w$。 举个例子，下方代码中，我们只能得到$C &amp;lt; D &amp;lt; E$和$C &amp;lt; A &amp;lt; B$，并不能得出$A &amp;lt; E$；因此即使偶然有循环$D$退出，也不能保证能打印出hello。 var a string var done bool func setup() { a = &quot;hello&quot; // A done = true // B } func main() { go setup() // C for !done { // D } print(a) // E } 解答 var isRunning = int32(1) func fg1() { for { isRunning-- // A } } func fg2() int { count := 1 for isRunning &amp;gt; 0 { // B count++ } return count } func main() { count := 0 go fg1() // C go func() { count = fg2() // D }() time.Sleep(3 * time.Second) println(isRunning) // E println(count) } 我们可以得出： $C &amp;lt; A$ $D &amp;lt; B$ $C &amp;lt; E$ 但我们不能得到$A$和$B$、$A$和$E$之间的早于关系。因此，编译器完全可以优化掉fg1中的赋值语句。详细讨论还可以见码客与Google Groups - golang-nuts（至于为什么编译器在short circuit阶段优化掉该赋值，尚在讨论之中，后续会继续更新）。 讨论 再来看一段代码： var hasLoad = uint32(0) var instance *T var m sync.Mutex func getInstance() *T { if hasLoad == 0 { // A m.Lock() if hasLoad == 0 { instance = &amp;amp;T{} hasLoad = 1 } m.Unlock() } } 这段代码究竟有没有问题？ 运行go run -race来查看data race的情况，马上会得到在$A$处会有一个协程写一个协程读的情况，我们之前的做法都是，把hasLoad的读写都使用sync/atomic包进行操作。但真的需要吗？ Go Memory Model: Advice Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access. To serialize access, protect the data with channel operations or other synchronization primitives such as those in the sync and sync/atomic packages. If you must read the rest of this document to understand the behavior of your program, you are being too clever. Don’t be clever. 被多个goroutines并发读写数据的程序必须串行化这样的读写。 为此，请使用channel操作或其他例如sync、sync/atomic中的同步原语保护该类数据。 如果你一定要阅读本文（笔者注：即Go Memory Model）剩余部分以理解你程序的行为，那么你就是耍小聪明了。 别耍小聪明。 遇到并发读写变量的情况，请一定使用mutex或atomic操作；我们可以认为这段代码是存在问题的。 可以跳过的小聪明分析 其实这段代码严格意义上是没有问题的，我们再来分析（为方便起见，我们假设只有2个协程访问getInstance，所以我们可以把它分别命名为getInstance1与getInstance2）： var hasLoad = uint32(0) var instance *T var m sync.Mutex func getInstance1() *T { // 和getInstance完全相同 if hasLoad == 0 { // A1 m.Lock() // B1 if hasLoad == 0 { // C1 instance = &amp;amp;T{} // D1 hasLoad = 1 // E1 } m.Unlock() // F1 } } func getInstance2() *T { // 和getInstance完全相同 if hasLoad == 0 { // A2 m.Lock() // B2 if hasLoad == 0 { // C2 instance = &amp;amp;T{} // D2 hasLoad = 1 // E2 } m.Unlock() // F2 } } func main() { go getInstance1() go getInstance2() } 我们假设$B_2 &amp;gt; F_1$，也就是说getInstance1先调用m.Lock()并最终m.Unlock()，然后才是getInstance2的m.Lock()返回（对称地可以分析另一情况，因此不再赘述）。 在getInstance1中，因为是串行执行，有$D_1 &amp;lt; E_1 &amp;lt; F_1$。 在getInstance2中，也是因为串行执行，有$B_2 &amp;lt; C_2$。 所以由假设$B_2 &amp;gt; F_1$，有$D_1 &amp;lt; E_1 &amp;lt; F_1 &amp;lt; B_2 &amp;lt; C_2$，由于对于hasLoad没有其他的写，根据保证，可以知道$E_1$中的hasLoad = 1可以被$C_2$中的if hasLoad == 0观察到，因此不会进入$D_2$、$E_2$，不会导致instance被多次赋值——代码是正确的。而$A_1$、$A_2$和$E_1$、$E_2$的data race其实无关紧要，因为有$C_1$、$C_2$处的双重校验，第一次m.Unlock()之前的hasLoad = 1被观察到了。 实际上可以运行以上代码，每次用多个协程调用getInstance，重复1000000次，没有一次有发生instance重复赋值。 结论 并发中意料之外的结果，总是有着情理之中的解释； 虽然仔细地分析可以得到结论，但还是请合理使用mutex与atomic操作。</summary></entry><entry><title type="html">深入Go：垃圾回收的演进</title><link href="http://localhost:4000/2021/02/19/%E6%B7%B1%E5%85%A5Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%BC%94%E8%BF%9B.html" rel="alternate" type="text/html" title="深入Go：垃圾回收的演进" /><published>2021-02-19T00:00:00+00:00</published><updated>2021-02-19T00:00:00+00:00</updated><id>http://localhost:4000/2021/02/19/%E6%B7%B1%E5%85%A5Go:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%BC%94%E8%BF%9B</id><content type="html" xml:base="http://localhost:4000/2021/02/19/%E6%B7%B1%E5%85%A5Go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%BC%94%E8%BF%9B.html">&lt;p&gt;Stop the world 是讨论垃圾回收（Garbage Collection，GC）时绕不开的话题，曾经Go语言的GC机制也威胁着服务的响应时间——Discord技术团队的文章《Why Discord is switching from Go to Rust》讨论了Go语言GC带来的问题。Go通过版本迭代已经极大地改善了GC的问题，平均每次STW时间从100+ms降低到了0.5ms——是什么神奇的魔法使得世界几乎无需暂停？在本文中，我们通过提问、解答的方式尝试对该演进的主要过程进行梳理。&lt;/p&gt;

&lt;h4 id=&quot;垃圾回收有哪些机制各有什么利弊&quot;&gt;垃圾回收有哪些机制，各有什么利弊？&lt;/h4&gt;

&lt;p&gt;垃圾回收主要有「引用计数」与「追踪」的机制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数（Reference Counting）：给每一个对象增加一个计数器，每当该对象被引用/解除引用时，则计数器自增/自减1；当该计数器归零时，则该对象应该被回收。&lt;/li&gt;
  &lt;li&gt;追踪（Tracing）：定期遍历内存空间，从若干根储存对象开始查找与之相关的存储对象，然后标记其余的没有关联的存储对象，最后回收这些没有关联的存储对象占用的内存空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两种方法各有好处和坏处：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;引用计数&lt;/th&gt;
      &lt;th&gt;追踪&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;需要暂停整个程序&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;运行时的额外开销&lt;/td&gt;
      &lt;td&gt;计数器的并发控制&lt;br /&gt;计数器的内存空间&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;无法回收的情况&lt;/td&gt;
      &lt;td&gt;对象循环引用*&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;*注：类似以下代码，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;person&lt;/code&gt;与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apartment&lt;/code&gt;的对象间循环引用，造成最终无法被基于循环引用的垃圾回收器回收。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;apartment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Apartment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apartment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apartment&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;apartment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;apartment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中，追踪的方法被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Java&lt;/code&gt;的多个垃圾回收算法、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Go&lt;/code&gt;语言等使用；引用计数的方法被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swift&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt;等使用，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C++&lt;/code&gt;的智能指针也可以被认为是引用计数的实现——其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt;提供循环引用检测，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swift&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;则使用ARC（&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html&quot;&gt;Automatic Reference Counting&lt;/a&gt;），需要代码编写者对引用类型进行判断，区分强引用与弱引用，例如&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Apartment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;go使用追踪式的垃圾回收机制具体是怎样的&quot;&gt;Go使用追踪式的垃圾回收机制具体是怎样的？&lt;/h4&gt;

&lt;p&gt;Go 1.5之后，使用三色标记法进行垃圾回收。&lt;/p&gt;

&lt;p&gt;传统的标记-清扫算法思想在70年代就提出了。某一时刻挂起用户程序（STW，stop the world），执行垃圾回收机制——分两个阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标记：从一些根节点开始标记对象，逐步遍历存活单元，直至无剩余可遍历单元；这一步需要STW，否则可能错误 回收用户新创建的对象。&lt;/li&gt;
  &lt;li&gt;清扫：回收剩余未标记单元。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三色标记法是对传统标记阶段的改进，分为白色（未扫描对象）、灰色（待遍历对象）与黑色（已遍历对象）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2021-02-19/mark-with-colors.png&quot; alt=&quot;mark with colors&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// 1. 标记所有栈上对象为灰色&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 2. 取出所有灰色对象并标记为黑色，将该对象引用的对象标记为灰色，直至没有灰色对象&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStackObjects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;markGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getNextGrayObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;markBlack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;markGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetReferences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;三色标记算法可以使得STW的时间大大减少，使得用户程序和垃圾回收算法能并发进行。实际上，Go 1.10版本之后，平均每次STW的时间降低到了&lt;strong&gt;0.5ms&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.golang.org/ismmkeynote/image6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;是什么原因使得用户程序和标记-清扫算法不能并发执行&quot;&gt;是什么原因使得用户程序和标记-清扫算法不能并发执行？&lt;/h4&gt;

&lt;p&gt;是因为用户程序对于标记过程的干扰。为避免错误清扫对象，从而需要STW。&lt;/p&gt;

&lt;p&gt;那么，“干扰”有哪些呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户新创建了对象——该对象一直保持白色，最后可能被错误地回收；&lt;/li&gt;
  &lt;li&gt;用户将一个白色对象从灰色对象解除引用，并使一个黑色对象引用它——该白色对象不会被扫描到，因为黑色对象意味着相关引用对象已经扫描完毕，从而该白色对象被错误地回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;与用户程序并行运行时的垃圾回收算法如何保证正确性&quot;&gt;与用户程序并行运行时的垃圾回收算法，如何保证正确性？&lt;/h4&gt;

&lt;p&gt;依赖于写屏障（Write Barrier）。写屏障本意是操作系统内的一种机制，它保证写入存储系统的过程按特定顺序进行；在垃圾回收算法中，写屏障是&lt;strong&gt;在每次写入时所执行的特定的代码&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们在标记过程中开启写屏障，从而试图避免用户程序对标记过程的干扰。Go 1.8之前的方法是使用Dijkstra在78年提出的方法——插入写屏障（Insertion Write Barrier）：&lt;/p&gt;

&lt;p&gt;每次引用发生的时候，如果被引用对象是白色，则将之设置为灰色，类似于：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writePointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isWhite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;markGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 设置引用&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这一写屏障恰好解决了上文提到的用户程序对于标记过程的干扰：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户新创建的对象，直接被标记为灰色，避免了错误回收；&lt;/li&gt;
  &lt;li&gt;当白色对象的父节点从灰色对象改为黑色对象时，该对象被标记为灰色，也避免了错误回收。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2021-02-19/insertion-write-barrier.png&quot; alt=&quot;insertion write barrier&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是因为插入写屏障满足了&lt;strong&gt;强三色不变性&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;插入写屏障有怎样的cost&quot;&gt;插入写屏障有怎样的cost？&lt;/h4&gt;

&lt;p&gt;栈上对象被置黑后，为了避免错误回收，要么需要对栈上对象加入写屏障（频繁操作开销增加），要么需要重新扫描栈（STW）。&lt;/p&gt;

&lt;p&gt;因此，Go在1.5版本至1.7版本，开启插入写屏障后，只对堆上的指针变动进行置灰，而对于栈上的指针不作更改；&lt;strong&gt;标记完成后的STW，会对栈上的白色对象重新进行一次标记&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Go从1.5以前每次STW耗时从~&lt;strong&gt;100ms&lt;/strong&gt;降低到了该阶段所需要花费的~&lt;strong&gt;10ms&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;如何进一步优化插入写屏障降低stw耗时&quot;&gt;如何进一步优化插入写屏障，降低STW耗时？&lt;/h4&gt;

&lt;p&gt;这里引入1990年由Yuasa提出的删除写屏障（Deletion Write Barrier）：&lt;/p&gt;

&lt;p&gt;对象的引用被删除时，如果该对象是白色，则该对象被置为灰色。代码示例如下：&lt;/p&gt;

&lt;p&gt;删除写屏障的可靠性来源于其满足&lt;strong&gt;弱三色不变性&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从而保证了白色对象在删除引用时，其自身和子节点总能在标记阶段被标记为黑色，从而避免错误回收造成悬垂指针。&lt;/p&gt;

&lt;p&gt;最终，Go 1.8版本引入了结合插入写屏障和删除写屏障的混合写屏障（Hybrid Write Barrier）：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writePointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isWhite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;markGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// [删除写屏障]删除引用时，被解除引用的对象标记灰色&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isCurrentStackGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;markGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 当前goroutine栈如果尚未被扫描完，则指针指向对象标记灰色&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 这是因为Go 1.8之前已经设置了，写屏障开启时，所有新对象都被标记为黑色&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 因此该指针所在的goroutine的栈还没被扫描时，该指针置为灰色以便进一步扫描&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 若当前指针所在goroutine已经为黑色时，&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// * 该指针要么已经被扫描（灰色/黑色）&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// *要么是新分配对象（黑色）&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;混合写屏障是否解决了插入写屏障的问题&quot;&gt;混合写屏障是否解决了插入写屏障的问题？&lt;/h5&gt;

&lt;p&gt;实际上问题在于：混合写屏障是否避免了1. 在标记结束后STW然后重新扫描栈； 2. 对栈上对象开启写屏障？&lt;/p&gt;

&lt;p&gt;插入写屏障之所以需要重新扫描栈，是白色对象被栈上黑色对象的指针引用；现在因为删除写屏障，这类白色对象会被置灰。因此无需重新扫描栈。且注意到，写屏障是对该类白色对象置灰而不会改变栈上黑色对象的颜色，因此避免了对栈上对象开启写屏障的性能损失。&lt;/p&gt;

&lt;p&gt;因此，Go 1.8引入的混合写屏障即保证了性能，又降低了重新扫描栈带来的STW开销。每次GC的STW时间从插入写屏障1.5版本的~10ms降低到了1.8的~0.5ms。&lt;/p&gt;

&lt;h4 id=&quot;go-18之后为什么还需要stw&quot;&gt;Go 1.8之后为什么还需要STW？&lt;/h4&gt;

&lt;p&gt;还有两个阶段需要STW：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GC开始前的准备工作，例如设置写屏障；&lt;/li&gt;
  &lt;li&gt;标记结束时，重新扫描全局变量、扫描系统栈、结束标记过程等。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">Stop the world 是讨论垃圾回收（Garbage Collection，GC）时绕不开的话题，曾经Go语言的GC机制也威胁着服务的响应时间——Discord技术团队的文章《Why Discord is switching from Go to Rust》讨论了Go语言GC带来的问题。Go通过版本迭代已经极大地改善了GC的问题，平均每次STW时间从100+ms降低到了0.5ms——是什么神奇的魔法使得世界几乎无需暂停？在本文中，我们通过提问、解答的方式尝试对该演进的主要过程进行梳理。 垃圾回收有哪些机制，各有什么利弊？ 垃圾回收主要有「引用计数」与「追踪」的机制： 引用计数（Reference Counting）：给每一个对象增加一个计数器，每当该对象被引用/解除引用时，则计数器自增/自减1；当该计数器归零时，则该对象应该被回收。 追踪（Tracing）：定期遍历内存空间，从若干根储存对象开始查找与之相关的存储对象，然后标记其余的没有关联的存储对象，最后回收这些没有关联的存储对象占用的内存空间。 这两种方法各有好处和坏处：   引用计数 追踪 需要暂停整个程序 否 是 运行时的额外开销 计数器的并发控制计数器的内存空间 无 无法回收的情况 对象循环引用* 无 *注：类似以下代码，person与apartment的对象间循环引用，造成最终无法被基于循环引用的垃圾回收器回收。 person = Person() apartment = Apartment() person.apartment = apartment apartment.owner = person person = None apartment = None 其中，追踪的方法被Java的多个垃圾回收算法、Go语言等使用；引用计数的方法被swift、Objective-C、Python等使用，C++的智能指针也可以被认为是引用计数的实现——其中Python提供循环引用检测，而swift、Objective-C则使用ARC（Automatic Reference Counting），需要代码编写者对引用类型进行判断，区分强引用与弱引用，例如 class Apartment { weak var owner: Person? } Go使用追踪式的垃圾回收机制具体是怎样的？ Go 1.5之后，使用三色标记法进行垃圾回收。 传统的标记-清扫算法思想在70年代就提出了。某一时刻挂起用户程序（STW，stop the world），执行垃圾回收机制——分两个阶段： 标记：从一些根节点开始标记对象，逐步遍历存活单元，直至无剩余可遍历单元；这一步需要STW，否则可能错误 回收用户新创建的对象。 清扫：回收剩余未标记单元。 三色标记法是对传统标记阶段的改进，分为白色（未扫描对象）、灰色（待遍历对象）与黑色（已遍历对象）： // 1. 标记所有栈上对象为灰色 // 2. 取出所有灰色对象并标记为黑色，将该对象引用的对象标记为灰色，直至没有灰色对象 func mark() { for object in range getStackObjects() { markGray(object) } for { object, ok := getNextGrayObject() if !ok { break } markBlack(object) markGray(object.GetReferences()) } } 三色标记算法可以使得STW的时间大大减少，使得用户程序和垃圾回收算法能并发进行。实际上，Go 1.10版本之后，平均每次STW的时间降低到了0.5ms： 是什么原因使得用户程序和标记-清扫算法不能并发执行？ 是因为用户程序对于标记过程的干扰。为避免错误清扫对象，从而需要STW。 那么，“干扰”有哪些呢？ 用户新创建了对象——该对象一直保持白色，最后可能被错误地回收； 用户将一个白色对象从灰色对象解除引用，并使一个黑色对象引用它——该白色对象不会被扫描到，因为黑色对象意味着相关引用对象已经扫描完毕，从而该白色对象被错误地回收。 与用户程序并行运行时的垃圾回收算法，如何保证正确性？ 依赖于写屏障（Write Barrier）。写屏障本意是操作系统内的一种机制，它保证写入存储系统的过程按特定顺序进行；在垃圾回收算法中，写屏障是在每次写入时所执行的特定的代码。 我们在标记过程中开启写屏障，从而试图避免用户程序对标记过程的干扰。Go 1.8之前的方法是使用Dijkstra在78年提出的方法——插入写屏障（Insertion Write Barrier）： 每次引用发生的时候，如果被引用对象是白色，则将之设置为灰色，类似于： func writePointer(slot, ptr) { if isWhite(ptr) { markGray(ptr) } *slot = ptr // 设置引用 } 这一写屏障恰好解决了上文提到的用户程序对于标记过程的干扰： 用户新创建的对象，直接被标记为灰色，避免了错误回收； 当白色对象的父节点从灰色对象改为黑色对象时，该对象被标记为灰色，也避免了错误回收。 这是因为插入写屏障满足了强三色不变性： 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。 插入写屏障有怎样的cost？ 栈上对象被置黑后，为了避免错误回收，要么需要对栈上对象加入写屏障（频繁操作开销增加），要么需要重新扫描栈（STW）。 因此，Go在1.5版本至1.7版本，开启插入写屏障后，只对堆上的指针变动进行置灰，而对于栈上的指针不作更改；标记完成后的STW，会对栈上的白色对象重新进行一次标记。 Go从1.5以前每次STW耗时从~100ms降低到了该阶段所需要花费的~10ms。 如何进一步优化插入写屏障，降低STW耗时？ 这里引入1990年由Yuasa提出的删除写屏障（Deletion Write Barrier）： 对象的引用被删除时，如果该对象是白色，则该对象被置为灰色。代码示例如下： 删除写屏障的可靠性来源于其满足弱三色不变性： 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径 从而保证了白色对象在删除引用时，其自身和子节点总能在标记阶段被标记为黑色，从而避免错误回收造成悬垂指针。 最终，Go 1.8版本引入了结合插入写屏障和删除写屏障的混合写屏障（Hybrid Write Barrier）： func writePointer(slot, ptr) { if isWhite(*slot) { markGray(*slot) // [删除写屏障]删除引用时，被解除引用的对象标记灰色 } if isCurrentStackGray() { markGray(ptr) // 当前goroutine栈如果尚未被扫描完，则指针指向对象标记灰色 // 这是因为Go 1.8之前已经设置了，写屏障开启时，所有新对象都被标记为黑色 // 因此该指针所在的goroutine的栈还没被扫描时，该指针置为灰色以便进一步扫描 // 若当前指针所在goroutine已经为黑色时， // * 该指针要么已经被扫描（灰色/黑色） // *要么是新分配对象（黑色） } *slot = ptr } 混合写屏障是否解决了插入写屏障的问题？ 实际上问题在于：混合写屏障是否避免了1. 在标记结束后STW然后重新扫描栈； 2. 对栈上对象开启写屏障？ 插入写屏障之所以需要重新扫描栈，是白色对象被栈上黑色对象的指针引用；现在因为删除写屏障，这类白色对象会被置灰。因此无需重新扫描栈。且注意到，写屏障是对该类白色对象置灰而不会改变栈上黑色对象的颜色，因此避免了对栈上对象开启写屏障的性能损失。 因此，Go 1.8引入的混合写屏障即保证了性能，又降低了重新扫描栈带来的STW开销。每次GC的STW时间从插入写屏障1.5版本的~10ms降低到了1.8的~0.5ms。 Go 1.8之后为什么还需要STW？ 还有两个阶段需要STW： GC开始前的准备工作，例如设置写屏障； 标记结束时，重新扫描全局变量、扫描系统栈、结束标记过程等。</summary></entry><entry><title type="html">深入Go：sync.Map</title><link href="http://localhost:4000/2020/11/27/%E6%B7%B1%E5%85%A5Go-sync.Map.html" rel="alternate" type="text/html" title="深入Go：sync.Map" /><published>2020-11-27T00:00:00+00:00</published><updated>2020-11-27T00:00:00+00:00</updated><id>http://localhost:4000/2020/11/27/%E6%B7%B1%E5%85%A5Go:sync.Map</id><content type="html" xml:base="http://localhost:4000/2020/11/27/%E6%B7%B1%E5%85%A5Go-sync.Map.html">&lt;p&gt;我们在使用Go的项目中需要有并发读写的map时，我们了解到Go提供&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;这一数据结构；通过对其简单了解，发现它正好适合我们需要的场景。随着了解的深入，我们又有了疑惑：为什么不像Java SE 8之前的ConcurrentHashMap一样，使用分段锁？为什么在内部需要一个哨兵指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;？这两个问题我们简单Google后都没有找到解析和讨论，因此我们决定深入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;的源代码，尝试回答这两个问题。&lt;/p&gt;

&lt;h4 id=&quot;太长不看版&quot;&gt;太长不看版&lt;/h4&gt;

&lt;h5 id=&quot;预备知识&quot;&gt;预备知识&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;map的读写删除都不是原子操作，因此需要控制并发访问，而Go的原生map不支持并发读写；&lt;/li&gt;
  &lt;li&gt;Go在1.9的版本中新增了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;的数据结构，通过空间换时间的方式降低了加锁的频率：
    &lt;ul&gt;
      &lt;li&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;两个map来保存键值，map的值为指向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;的指针，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;存储指向真实值的指针&lt;/li&gt;
      &lt;li&gt;当需要向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中插入新值时，如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;为空则将除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry.p == nil&lt;/code&gt;外的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;的键值浅拷贝到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;的处理我们后面会详细讨论，这也是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;的highlight）&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中包含的键可不加锁地读和删（不是删除对应值，而是将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry.p = nil&lt;/code&gt;以表示对应值被删除了）&lt;/li&gt;
      &lt;li&gt;除了一种特殊情况外，更新&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中已经存在的键的值也无需加锁，该特殊情况在后文会详细讲到&lt;/li&gt;
      &lt;li&gt;对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;的读写删除都需要加锁，当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中没有的键值时（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.amended = true&lt;/code&gt;），会
        &lt;ul&gt;
          &lt;li&gt;读写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中不存在的键：加锁并在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中完成对应操作&lt;/li&gt;
          &lt;li&gt;删除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中不存在的键：直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete(dirty, key)&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;当对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中的访问数量大于其长度时，直接将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中map的指针替换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;，并将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.amended&lt;/code&gt;置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;两个问题的回答&quot;&gt;两个问题的回答&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;为什么不像Java SE 8之前的ConcurrentHashMap一样，使用分段锁？
    &lt;ul&gt;
      &lt;li&gt;我们猜测是因为为了避免重写一套map的逻辑，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;可以直接使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;作为内部的实现而无需重写分配到哪一段的hashing逻辑；&lt;/li&gt;
      &lt;li&gt;也因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;的适用场景和ConcurrentHashMap不同。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;适合读写删除的键值范围比较固定的情况（即基本都能在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中命中而无需加锁查询&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;），不适合需要频繁增加、访问新值的情况（即频繁读写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;）。后者建议使用分段锁的map。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;哨兵指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;有什么作用？
    &lt;ul&gt;
      &lt;li&gt;为了保证&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;键值的同步，以保证在将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;替换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;时能一步完成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;为什么需要可并发访问的map&quot;&gt;为什么需要可并发访问的Map&lt;/h4&gt;

&lt;p&gt;Map是Go语言中广泛使用的数据结构，但它并不是可并发读写的。尝试以下代码，会得到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fatal error: concurrent map read and map write&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是因为在Map的源码中，有&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mapaccess1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maptype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 如果在读map的时候检测到hashWriting flag为1（即，有协程在写该map）则panic&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hashWriting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;concurrent map read and map write&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本质上是因为，map的读写都不是“原子操作”，试想：当你尝试读（copy）一个struct的时候，突然另一个协程将该struct删除并触发垃圾回收、或者另一个协程更新了该struct——我们就变成了读一个非法的struct，从而导致问题。&lt;/p&gt;

&lt;p&gt;在实践中，往往我们又需要一个可并发读写的Map。那么，如何解决？&lt;/p&gt;

&lt;h4 id=&quot;并发读写的map&quot;&gt;并发读写的Map&lt;/h4&gt;

&lt;p&gt;我们不假思索就可以想到，可以通过加锁解决——每次读写，我们都给map加上mutex——但加锁意味着性能损失，因此我们要尝试减少加锁的次数。&lt;/p&gt;

&lt;p&gt;首先我们可以考虑使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RWMutex&lt;/code&gt;——该mutex可被任意多的读协程获取，或被一个写协程获取——使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RWMutex&lt;/code&gt;直接降低了多读少写的Map的性能损失。&lt;/p&gt;

&lt;p&gt;当然，我们也可以借鉴Java SE 8之前经典的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的实现方式——将Map进行分段，每个分段进行加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RWMutex&lt;/code&gt;的操作。这一思路在orcaman实现的&lt;a href=&quot;https://github.com/orcaman/concurrent-map&quot;&gt;concurrent-map&lt;/a&gt;中被使用。&lt;/p&gt;

&lt;p&gt;Go的思路和Java的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;不同，因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;总的来说是对map的重写，因为分段加锁需要新的hashing逻辑（因此orcaman实现的concurrent-map，就是为了避免实现新的hashing逻辑，所以只支持键的类型为string）；Go的map本来已经实现得非常优秀，那么如何利用已经存在的map，构建出并发读写安全的数据结构呢？&lt;/p&gt;

&lt;h4 id=&quot;introducing-syncmap&quot;&gt;Introducing sync.Map&lt;/h4&gt;

&lt;p&gt;Go在1.9的版本中引入了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;这一支持并发读写的数据结构，其利用空间换时间的思路，使用成员&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;来优化固定场景下读写的性能——只对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;的访问加锁，即当用户读写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中的entry时，sync.Map并不加锁，当用户读写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中存在的entry时，sync.Map才对该操作加锁。我们接下来通过读&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;的&lt;a href=&quot;https://github.com/golang/go/blob/master/src/sync/map.go&quot;&gt;源代码&lt;/a&gt;来了解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;有着怎样的结构&lt;/li&gt;
  &lt;li&gt;如何读&lt;/li&gt;
  &lt;li&gt;如何写&lt;/li&gt;
  &lt;li&gt;如何删&lt;/li&gt;
  &lt;li&gt;为何使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;优化了哪些场景下的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;syncmap的结构&quot;&gt;sync.Map的结构&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;作为底层的实现，因此其内部继承了map良好的读写性能；不过其依赖的底层&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;存储的“值”并不是存的用户提供的值，而是指向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;的指针类型，用以判断对应键值的状态，关于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;的代码如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// expunged是初始化时随机生成的哨兵值，&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// 标志该值已经从map的read中删除且不存在于dirty中。&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expunged&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// p为指针，可指向：&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// -&amp;gt; nil，表示对应键值已从map的read中删除，但存在于dirty中&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// -&amp;gt; expunged，表示对应键值已从map中删除，但不存在于dirty中&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// -&amp;gt; 其他地址，指向真实数据&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsafe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pointer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;成员&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readOnly&lt;/code&gt;结构体：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果dirty包含read中不包含的entry指针时为true。&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面我们就可以来看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;本身的代码了。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;
  
   &lt;span class=&quot;c&quot;&gt;// read包含并发安全的map部分，访问它（的entries）永远不用加锁&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 当entry需要从read删除时，并不直接删除该entry的指针e，&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 而是将e.p置为nil。&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 除了进行写操作且对应键的entry的e.p == expunged时，&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// （此时也不是对read加锁，而是对dirty加锁）&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 对read中的键值进行读、写和删除都不用加锁。&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// readOnly&lt;/span&gt;

   &lt;span class=&quot;c&quot;&gt;// dirty包括map中需要加锁读写的部分。&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 为保证从dirty至read的更新耗时足够小，&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 因此需要把read中从expunged状态恢复的entry加入dirty&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// （此时read仍未被加锁，是写到dirty从而对dirty加锁）。&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 当向dirty写的时候，如果dirty为nil，&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 则需要浅拷贝read（unplunged entries除外，详情见Store代码）&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;

   &lt;span class=&quot;c&quot;&gt;// misses是计算read更新后访问map时获取mu的计数器&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;// 当misses数量超过dirty长度时，dirty会跃升为新的read并将dirty置为nil&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;misses&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;load操作&quot;&gt;Load操作&lt;/h5&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果找不到，且dirty含有新键值&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 双重检查，避免另一协程已经将read替换为dirty&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// 从dirty中获取&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// 增加misses计数，如果超过len(dirty)则将read替换为dirty并将dirty置为nil&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;missLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 未找到对应键&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 返回真实值&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此我们可以知道，以下情况&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Load&lt;/code&gt;不需要加锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.amended == false&lt;/code&gt;的时候，此时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty == nil&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;存在于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.m&lt;/code&gt;中，无论对应entry的指针为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;还是真实地址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;不存在于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.m&lt;/code&gt;中、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.amended == true&lt;/code&gt;时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Load&lt;/code&gt;需要去&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中检查一次。&lt;/p&gt;

&lt;h5 id=&quot;store操作&quot;&gt;Store操作&lt;/h5&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// tryStore：当e.p为expunged时返回false，否则存储&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tryStore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;c&quot;&gt;// 这里，未加锁尝试store&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 因为read的entry非expunged时，要么dirty为空则无需操作dirty&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 否则该entry指针一定和dirty中对应的entry指针指向同一entry&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 因此只需改这里就可以使dirty中值保持一致（从而也无需加锁）&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 

    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 否则需要加锁访问&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unexpungeLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 此前e为expunged状态，将对应`e.p`置为nil&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// expunged状态说明此时dirty不为nil且该键不在dirty中，直接存到dirty&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storeLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 然后store pointer到entry e&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 此时为dirty中有值的状态&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;storeLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 此时为dirty中无该值的状态&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 此时为dirty中第一个值&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirtyLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 创建m.dirty并根据read初始化，如下&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/*
func (m *Map) dirtyLocked() {
    if m.dirty != nil { // 此时m.dirty一定是nil，否则不会调用dirtyLocked
        return
    }

    read, _ := m.read.Load().(readOnly)
    m.dirty = make(map[interface{}]*entry, len(read.m))
    for k, e := range read.m { // 处理read中每个entry
        if !e.tryExpungeLocked() { // 将read中含空指针的entry变为expunged并返回true
            m.dirty[k] = e // 因此read中为expunged的entry在dirty中一定不存在对应entry
        }
    }
}*/&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// 现在有dirty了，改动amended&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newEntry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 在dirty中存储新值，此时该值仅在dirty中存在&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此我们可以知道，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Store&lt;/code&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;对应的entry &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.p != expunged&lt;/code&gt;时不用加锁，除此之外都需要加锁，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.p == expunged&lt;/code&gt;状态，需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m.dirty[key] = e&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key&lt;/code&gt;不在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read.m&lt;/code&gt;中时，需要直接写到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;（可能触发&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;的浅拷贝）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;delete操作&quot;&gt;Delete操作&lt;/h5&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// LoadAndDelete被Delete调用，是实施删除键值的函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LoadAndDelete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loaded&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果在read中找到，直接跳到下方e.delete()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 说明仅仅存在于dirty中&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 双重检查&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amended&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 在dirty中删除，此时read、dirty中都不再有该键&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;missLocked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 增加misses，如果需要则用dirty替换read&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// 如果有真实值，则将其置为nil&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/*
func (e *entry) delete() (value interface{}, ok bool) {
    for {
        p := atomic.LoadPointer(&amp;amp;e.p)
        if p == nil || p == expunged {
            return nil, false
        }
        if atomic.CompareAndSwapPointer(&amp;amp;e.p, p, nil) {
            return *(*interface{})(p), true
        }
    }
} */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Load&lt;/code&gt;类似，删除&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中存在的键值无需加锁，否则需要加锁然后直接&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete(dirty, key)&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;为何需要expunged的值&quot;&gt;为何需要expunged的值&lt;/h5&gt;

&lt;p&gt;entry的指针一共有三个可选值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;和指向真实的元素。为了弄清楚为什么使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;，我们需要知道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指针在什么时候会变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;的值&lt;/li&gt;
  &lt;li&gt;为什么不仅仅使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一点，通过阅读代码我们知道，一个entry的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;当且仅当在加锁后、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;为空，从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;浅拷贝所有entry指针到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;的时候——此时的read中所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;的entry指针，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;都变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expunged&lt;/code&gt;，此时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中将不会有对应entry的指针。&lt;/p&gt;

&lt;p&gt;第二点，我们来看看如果仅仅使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;会发生什么：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;浅拷贝至&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;的时候仍然保留entry的指针，即拷贝完成后，对应键值下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;中都有对应键下entry e的指针，且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e.p = nil&lt;/code&gt;，那么之后在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;跃升为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;的时候对应entry的指针仍然会保留——那么对应键的entry指针&lt;strong&gt;永远都会存在&lt;/strong&gt;，也就是说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;的规模只会越来越大；&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;浅拷贝时不进入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;，那么之后store对应键的时候，就会出现&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;不同步的情况，即此时&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;不包含的键，那么之后用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dirty&lt;/code&gt;替换&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;的时候就会出现数据丢失的问题；&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;浅拷贝时直接把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;中对应键删除（从而避免了不同步的问题），但这又必须对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;加锁，违背了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;读写不加锁的初衷。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;syncmap优化了哪些情况下的性能&quot;&gt;sync.Map优化了哪些情况下的性能&lt;/h5&gt;

&lt;p&gt;从代码中我们可以知道，对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;的访问是不需要加锁的，因此对于读多更新多而插入新值少的情况，也就是读写删的键值范围基本固定的情况下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;有着更佳的性能，因为读写删存在的键基本无需加锁；反复插入与读取新值，即操作dirty的情况更多时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sync.Map&lt;/code&gt;需要频繁加锁、更新&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;，从而性能会变差，因此不适合作为in-memory数据库使用（这样的情形更适合于使用利用分段锁的map）。&lt;/p&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Go" /><summary type="html">我们在使用Go的项目中需要有并发读写的map时，我们了解到Go提供sync.Map这一数据结构；通过对其简单了解，发现它正好适合我们需要的场景。随着了解的深入，我们又有了疑惑：为什么不像Java SE 8之前的ConcurrentHashMap一样，使用分段锁？为什么在内部需要一个哨兵指针expunged？这两个问题我们简单Google后都没有找到解析和讨论，因此我们决定深入sync.Map的源代码，尝试回答这两个问题。 太长不看版 预备知识 map的读写删除都不是原子操作，因此需要控制并发访问，而Go的原生map不支持并发读写； Go在1.9的版本中新增了sync.Map的数据结构，通过空间换时间的方式降低了加锁的频率： 使用read和dirty两个map来保存键值，map的值为指向entry的指针，entry存储指向真实值的指针 当需要向dirty中插入新值时，如果dirty为空则将除entry.p == nil外的read的键值浅拷贝到dirty（nil的处理我们后面会详细讨论，这也是sync.Map的highlight） read中包含的键可不加锁地读和删（不是删除对应值，而是将entry.p = nil以表示对应值被删除了） 除了一种特殊情况外，更新read中已经存在的键的值也无需加锁，该特殊情况在后文会详细讲到 对dirty的读写删除都需要加锁，当dirty中包含read中没有的键值时（read.amended = true），会 读写read中不存在的键：加锁并在dirty中完成对应操作 删除read中不存在的键：直接delete(dirty, key) 当对dirty中的访问数量大于其长度时，直接将read中map的指针替换为dirty，并将dirty置为nil、read.amended置为false。 两个问题的回答 为什么不像Java SE 8之前的ConcurrentHashMap一样，使用分段锁？ 我们猜测是因为为了避免重写一套map的逻辑，sync.Map可以直接使用map作为内部的实现而无需重写分配到哪一段的hashing逻辑； 也因为sync.Map的适用场景和ConcurrentHashMap不同。sync.Map适合读写删除的键值范围比较固定的情况（即基本都能在read中命中而无需加锁查询read），不适合需要频繁增加、访问新值的情况（即频繁读写dirty）。后者建议使用分段锁的map。 哨兵指针expunged有什么作用？ 为了保证dirty和read键值的同步，以保证在将read替换为dirty时能一步完成。 为什么需要可并发访问的Map Map是Go语言中广泛使用的数据结构，但它并不是可并发读写的。尝试以下代码，会得到fatal error: concurrent map read and map write。 func main() { m := make(map[int]int) go func() { for i := 0; i &amp;lt; 100000; i += 1 { m[i] = i } }() for i := 0; i &amp;lt; 100000; i += 1 { _ = m[i] } } 这是因为在Map的源码中，有 func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { ... // 如果在读map的时候检测到hashWriting flag为1（即，有协程在写该map）则panic if h.flags&amp;amp;hashWriting != 0 { throw(&quot;concurrent map read and map write&quot;) } } 本质上是因为，map的读写都不是“原子操作”，试想：当你尝试读（copy）一个struct的时候，突然另一个协程将该struct删除并触发垃圾回收、或者另一个协程更新了该struct——我们就变成了读一个非法的struct，从而导致问题。 在实践中，往往我们又需要一个可并发读写的Map。那么，如何解决？ 并发读写的Map 我们不假思索就可以想到，可以通过加锁解决——每次读写，我们都给map加上mutex——但加锁意味着性能损失，因此我们要尝试减少加锁的次数。 首先我们可以考虑使用RWMutex——该mutex可被任意多的读协程获取，或被一个写协程获取——使用RWMutex直接降低了多读少写的Map的性能损失。 当然，我们也可以借鉴Java SE 8之前经典的ConcurrentHashMap的实现方式——将Map进行分段，每个分段进行加RWMutex的操作。这一思路在orcaman实现的concurrent-map中被使用。 Go的思路和Java的ConcurrentHashMap不同，因为ConcurrentHashMap总的来说是对map的重写，因为分段加锁需要新的hashing逻辑（因此orcaman实现的concurrent-map，就是为了避免实现新的hashing逻辑，所以只支持键的类型为string）；Go的map本来已经实现得非常优秀，那么如何利用已经存在的map，构建出并发读写安全的数据结构呢？ Introducing sync.Map Go在1.9的版本中引入了sync.Map这一支持并发读写的数据结构，其利用空间换时间的思路，使用成员read、dirty来优化固定场景下读写的性能——只对dirty的访问加锁，即当用户读写read中的entry时，sync.Map并不加锁，当用户读写dirty中存在的entry时，sync.Map才对该操作加锁。我们接下来通过读sync.Map的源代码来了解： sync.Map有着怎样的结构 如何读 如何写 如何删 为何使用expunged值 sync.Map优化了哪些场景下的性能 sync.Map的结构 sync.Map使用map作为底层的实现，因此其内部继承了map良好的读写性能；不过其依赖的底层map存储的“值”并不是存的用户提供的值，而是指向entry的指针类型，用以判断对应键值的状态，关于entry的代码如下： // expunged是初始化时随机生成的哨兵值， // 标志该值已经从map的read中删除且不存在于dirty中。 var expunged = unsafe.Pointer(new(interface{})) type entry struct { // p为指针，可指向： // -&amp;gt; nil，表示对应键值已从map的read中删除，但存在于dirty中 // -&amp;gt; expunged，表示对应键值已从map中删除，但不存在于dirty中 // -&amp;gt; 其他地址，指向真实数据 p unsafe.Pointer } 然后看sync.Map中read成员readOnly结构体： type readOnly struct { m map[interface{}]*entry amended bool // 如果dirty包含read中不包含的entry指针时为true。 } 下面我们就可以来看sync.Map本身的代码了。 type Map struct { mu Mutex // read包含并发安全的map部分，访问它（的entries）永远不用加锁 // 当entry需要从read删除时，并不直接删除该entry的指针e， // 而是将e.p置为nil。 // 除了进行写操作且对应键的entry的e.p == expunged时， // （此时也不是对read加锁，而是对dirty加锁） // 对read中的键值进行读、写和删除都不用加锁。 read atomic.Value // readOnly // dirty包括map中需要加锁读写的部分。 // 为保证从dirty至read的更新耗时足够小， // 因此需要把read中从expunged状态恢复的entry加入dirty // （此时read仍未被加锁，是写到dirty从而对dirty加锁）。 // 当向dirty写的时候，如果dirty为nil， // 则需要浅拷贝read（unplunged entries除外，详情见Store代码） dirty map[interface{}]*entry // misses是计算read更新后访问map时获取mu的计数器 // 当misses数量超过dirty长度时，dirty会跃升为新的read并将dirty置为nil misses int } Load操作 func (m *Map) Load(key interface{}) (value interface{}, ok bool) { read, _ := m.read.Load().(readOnly) e, ok := read.m[key] if !ok &amp;amp;&amp;amp; read.amended { // 如果找不到，且dirty含有新键值 m.mu.Lock() // 双重检查，避免另一协程已经将read替换为dirty read, _ = m.read.Load().(readOnly) e, ok = read.m[key] if !ok &amp;amp;&amp;amp; read.amended { // 从dirty中获取 e, ok = m.dirty[key] // 增加misses计数，如果超过len(dirty)则将read替换为dirty并将dirty置为nil m.missLocked() } m.mu.Unlock() } if !ok { // 未找到对应键 return nil, false } return e.load() // 返回真实值 } 因此我们可以知道，以下情况Load不需要加锁： 当read.amended == false的时候，此时dirty == nil key存在于read.m中，无论对应entry的指针为nil、expunged还是真实地址 而当key不存在于read.m中、read.amended == true时，Load需要去dirty中检查一次。 Store操作 func (m *Map) Store(key, value interface{}) { read, _ := m.read.Load().(readOnly) // tryStore：当e.p为expunged时返回false，否则存储 if e, ok := read.m[key]; ok &amp;amp;&amp;amp; e.tryStore(&amp;amp;value) { // 这里，未加锁尝试store // 因为read的entry非expunged时，要么dirty为空则无需操作dirty // 否则该entry指针一定和dirty中对应的entry指针指向同一entry // 因此只需改这里就可以使dirty中值保持一致（从而也无需加锁） return } m.mu.Lock() // 否则需要加锁访问 read, _ = m.read.Load().(readOnly) if e, ok := read.m[key]; ok { if e.unexpungeLocked() { // 此前e为expunged状态，将对应`e.p`置为nil // expunged状态说明此时dirty不为nil且该键不在dirty中，直接存到dirty m.dirty[key] = e } e.storeLocked(&amp;amp;value) // 然后store pointer到entry e } else if e, ok := m.dirty[key]; ok { // 此时为dirty中有值的状态 e.storeLocked(&amp;amp;value) } else { // 此时为dirty中无该值的状态 if !read.amended { // 此时为dirty中第一个值 m.dirtyLocked() // 创建m.dirty并根据read初始化，如下 /* func (m *Map) dirtyLocked() { if m.dirty != nil { // 此时m.dirty一定是nil，否则不会调用dirtyLocked return } read, _ := m.read.Load().(readOnly) m.dirty = make(map[interface{}]*entry, len(read.m)) for k, e := range read.m { // 处理read中每个entry if !e.tryExpungeLocked() { // 将read中含空指针的entry变为expunged并返回true m.dirty[k] = e // 因此read中为expunged的entry在dirty中一定不存在对应entry } } }*/ // 现在有dirty了，改动amended m.read.Store(readOnly{m: read.m, amended: true}) } m.dirty[key] = newEntry(value) // 在dirty中存储新值，此时该值仅在dirty中存在 } m.mu.Unlock() } 因此我们可以知道，Store在key对应的entry e.p != expunged时不用加锁，除此之外都需要加锁，包括： e.p == expunged状态，需要m.dirty[key] = e 当key不在read.m中时，需要直接写到dirty（可能触发dirty从read的浅拷贝） Delete操作 // LoadAndDelete被Delete调用，是实施删除键值的函数 func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) { read, _ := m.read.Load().(readOnly) e, ok := read.m[key] // 如果在read中找到，直接跳到下方e.delete() if !ok &amp;amp;&amp;amp; read.amended { // 说明仅仅存在于dirty中 m.mu.Lock() read, _ = m.read.Load().(readOnly) // 双重检查 e, ok = read.m[key] if !ok &amp;amp;&amp;amp; read.amended { e, ok = m.dirty[key] delete(m.dirty, key) // 在dirty中删除，此时read、dirty中都不再有该键 m.missLocked() // 增加misses，如果需要则用dirty替换read } m.mu.Unlock() } if ok { return e.delete() // 如果有真实值，则将其置为nil /* func (e *entry) delete() (value interface{}, ok bool) { for { p := atomic.LoadPointer(&amp;amp;e.p) if p == nil || p == expunged { return nil, false } if atomic.CompareAndSwapPointer(&amp;amp;e.p, p, nil) { return *(*interface{})(p), true } } } */ } return nil, false } 和Load类似，删除read中存在的键值无需加锁，否则需要加锁然后直接delete(dirty, key)。 为何需要expunged的值 entry的指针一共有三个可选值，nil、expunged和指向真实的元素。为了弄清楚为什么使用expunged，我们需要知道： 指针在什么时候会变为expunged的值 为什么不仅仅使用nil 第一点，通过阅读代码我们知道，一个entry的p变为expunged当且仅当在加锁后、dirty为空，从read浅拷贝所有entry指针到dirty的时候——此时的read中所有p为nil的entry指针，p都变为expunged，此时dirty中将不会有对应entry的指针。 第二点，我们来看看如果仅仅使用nil会发生什么： 如果nil在read浅拷贝至dirty的时候仍然保留entry的指针，即拷贝完成后，对应键值下read和dirty中都有对应键下entry e的指针，且e.p = nil，那么之后在dirty跃升为read的时候对应entry的指针仍然会保留——那么对应键的entry指针永远都会存在，也就是说，sync.Map的规模只会越来越大； 如果nil在read浅拷贝时不进入dirty，那么之后store对应键的时候，就会出现read和dirty不同步的情况，即此时read中包含dirty不包含的键，那么之后用dirty替换read的时候就会出现数据丢失的问题； 如果nil在read浅拷贝时直接把read中对应键删除（从而避免了不同步的问题），但这又必须对read加锁，违背了read读写不加锁的初衷。 sync.Map优化了哪些情况下的性能 从代码中我们可以知道，对于read的访问是不需要加锁的，因此对于读多更新多而插入新值少的情况，也就是读写删的键值范围基本固定的情况下，sync.Map有着更佳的性能，因为读写删存在的键基本无需加锁；反复插入与读取新值，即操作dirty的情况更多时，sync.Map需要频繁加锁、更新read，从而性能会变差，因此不适合作为in-memory数据库使用（这样的情形更适合于使用利用分段锁的map）。</summary></entry><entry><title type="html">扔球进桶与负载均衡</title><link href="http://localhost:4000/2020/06/28/%E6%89%94%E7%90%83%E8%BF%9B%E6%A1%B6%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html" rel="alternate" type="text/html" title="扔球进桶与负载均衡" /><published>2020-06-28T00:00:00+00:00</published><updated>2020-06-28T00:00:00+00:00</updated><id>http://localhost:4000/2020/06/28/%E6%89%94%E7%90%83%E8%BF%9B%E6%A1%B6%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1</id><content type="html" xml:base="http://localhost:4000/2020/06/28/%E6%89%94%E7%90%83%E8%BF%9B%E6%A1%B6%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html">&lt;p&gt;同事介绍负载均衡算法时透露，其原B站leader透露说B站的负载均衡算法是基于一篇对扔球进桶问题讨论的论文。正好笔者曾看过相关内容，也深感这一简单的概率游戏有着让人意外的结果，故希望写一系列的文章，介绍这一简单而优美的结果。本篇文章为该系列文章的集合。&lt;/p&gt;

&lt;p&gt;在服务器的负载均衡模型中，我们可以把负载均衡看作是“扔球进桶”的游戏——我们的目标即&lt;strong&gt;最小化含有球数量最高的桶里的球的数量&lt;/strong&gt;。在讨论中，有三种模型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态模型：把球&lt;strong&gt;一个一个地&lt;/strong&gt;扔进桶里（扔第$i$个球时，前$i-1$个球被扔进了哪里是已经确定的）；&lt;/li&gt;
  &lt;li&gt;并行化模型：所有的球&lt;strong&gt;同时&lt;/strong&gt;扔进桶里（扔球没有顺序关系）；&lt;/li&gt;
  &lt;li&gt;动态模型：球按一定规律随时间到来，每个桶按一定的速度消耗掉球。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，动态模型最接近真实情况。为简便起见，我们将在本系列文章中详细讨论&lt;strong&gt;把$n$个球扔进$n$个桶的静态模型&lt;/strong&gt;，并介绍更接近于真实负载均衡场景的静态模型中球数多项式倍于桶数的情况与其他模型的结论。&lt;/p&gt;

&lt;p&gt;我们希望详细讨论的问题有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完全随机地扔$n$个球进$n$个桶里，最后球最多的桶里的球数的期望是多少？&lt;/li&gt;
  &lt;li&gt;扔$n$个球进$n$个桶里，每次完全随机地挑两个桶，把球扔进球数较少的桶里，最后的结果有怎样的改变？&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;一远离期望&quot;&gt;一、远离期望&lt;/h1&gt;

&lt;h2 id=&quot;意料之外与情理之中生日问题&quot;&gt;意料之外与情理之中：生日问题&lt;/h2&gt;

&lt;p&gt;假设所有人的生日为365天之中的其中一天，且机会均等。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当优图实验室有多少人时，我们可以&lt;strong&gt;保证有两人的生日是在同一天&lt;/strong&gt;？&lt;/li&gt;
  &lt;li&gt;随机选取$n$人，估计这$n$人中&lt;strong&gt;存在两人生日是在同一天&lt;/strong&gt;的概率大致是以下数字中的哪一个：
    &lt;ul&gt;
      &lt;li&gt;$n = 7$&lt;/li&gt;
      &lt;li&gt;$n = 23$&lt;/li&gt;
      &lt;li&gt;$n = 60$&lt;/li&gt;
      &lt;li&gt;$n = 183$
\(0.01\%, 1\%, 5\%, 25\%, 50\%, 90\%, 99.9999\%\)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于第一题，根据鸽笼原理，答案是$366$人。
对于第二题，结果可能出人意料：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$n = 7,\ 5.23\%$&lt;/li&gt;
  &lt;li&gt;$n = 23,\ 50.72\%$&lt;/li&gt;
  &lt;li&gt;$n = 60,\ 99.41\%$&lt;/li&gt;
  &lt;li&gt;$n = 183,\ \sim 1-{10}^{24}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其计算方法是：&lt;/p&gt;

&lt;p&gt;当有$n$人时，不存在两人生日在同一天的情况有
$b(n) = {365 \choose n} \cdot n!$ 种，而$n$人生日的所有情况有$365^n$种。因此，存在两人生日在同一天的“概率”为：&lt;/p&gt;

&lt;p&gt;\(\Pr(\textrm{ex. 2 people who have the same birthday}) = 1-b(n)/365^n,\)
可画出图如下：
&lt;img src=&quot;/static/images/2020-06-28/
birthdays.jpg&quot; alt=&quot;birthdays&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;随机变量期望以及远离期望&quot;&gt;随机变量、期望，以及远离期望&lt;/h2&gt;

&lt;p&gt;在本节中，我们将介绍概率论中的几个基本概念，以及在讨论中会使用到的几个不等式。在讨论中，我们都以扔硬币游戏为例。&lt;/p&gt;

&lt;p&gt;在这里我们不严格定义概率和概率空间；我们可以称“概率”，是指样本空间$\Omega$（随机过程中可能的结果）中允许的“事件”由概率函数$\Pr$得到的数值；这里，概率函数的值域为1，且$\Pr(\Omega) = 1$，且对于彼此独立的事件$E_1, \dots$有$\Pr(\cup_{i\geq 1} E_i) = \sum_{i \geq 1} \Pr(E_i)$。&lt;/p&gt;

&lt;p&gt;例如扔一枚均匀的硬币，样本空间为$\Omega = {\textrm{Head, Tail}}$，允许的事件即为正面朝上（Head）与反面朝上（Tail），而概率函数选择为：&lt;/p&gt;

\[\Pr(E) = \begin{cases}0.5,\qquad E = \textrm{Head,}\\ 0.5, \qquad E = \textrm{Tail.} \end{cases}\]

&lt;h3 id=&quot;随机变量&quot;&gt;随机变量&lt;/h3&gt;

&lt;p&gt;随机变量$X$是将样本空间映射到实数值的函数，即$X: \Omega \to R$. 与概率函数不同，随机变量无需具有概率函数的三性质。&lt;/p&gt;

&lt;p&gt;例如，在扔硬币游戏中，我们定义$X$为：&lt;/p&gt;

\[X = \begin{cases}1,\qquad E = \textrm{Head},\\0, \qquad E = \textrm{Tail}.\end{cases}\]

&lt;p&gt;该随机变量即描述了扔一枚均匀的硬币，扔出正面获得$1$元，否则获得$0$元的规则。&lt;/p&gt;

&lt;h3 id=&quot;数学期望&quot;&gt;数学期望&lt;/h3&gt;

&lt;p&gt;假设扔一枚均匀的硬币，扔出正面获得$1$元，否则获得$0$元。玩一次该游戏，我们期望能有多少受益？&lt;/p&gt;

&lt;p&gt;我们的直观告诉我们，我们期望收益是$0.5$元。&lt;/p&gt;

&lt;p&gt;随机变量$X$的数学期望也是按这样的思路定义：&lt;/p&gt;

&lt;p&gt;$E[X] = \sum_i i\cdot \Pr(X = i)$.&lt;/p&gt;

&lt;p&gt;因此我们可以计算，玩一次扔硬币游戏的期望是：&lt;/p&gt;

&lt;p&gt;$E[X] = 1\times 0.5 + 0\times 0.5 = 0.5$.&lt;/p&gt;

&lt;p&gt;容易证明，数学期望具有线性，即$E[aX + bY] = aE[X] + bE[Y]$.&lt;/p&gt;

&lt;h3 id=&quot;远离数学期望的概率&quot;&gt;远离数学期望的概率&lt;/h3&gt;

&lt;p&gt;我们继续扔硬币游戏，假设连续玩$n$次（其随机变量分别定义为$X_1, \dots, X_n$），我们定义$X = X_1 + \dots + X_n$，则$X$的期望是多少？&lt;/p&gt;

&lt;p&gt;$E[X] = E[\sum_{i=1}^n X_i] = \sum_{i=1}^n E[X_i] = 0.5n$.&lt;/p&gt;

&lt;p&gt;但是仍然有可能，我们的收益远少于$0.5n$（例如连续扔出$n$次反面），因此我们想要限制随机变量的值远离其期望的概率。&lt;/p&gt;

&lt;h4 id=&quot;马尔科夫不等式markov-inequality&quot;&gt;马尔科夫不等式（Markov Inequality）&lt;/h4&gt;

&lt;p&gt;对于取值非负的随机变量$X$，对于任意的$a&amp;gt;0$，有
\(\Pr(X\geq a)\leq E[X]/a.\)&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;当$a &amp;gt; 0$，令
\(I=\begin{cases}1,\qquad X\geq a\\ 0,\qquad \textrm{otherwise.}\end{cases}\)&lt;/p&gt;

&lt;p&gt;则根据$I$的定义，有$I \leq X/a$。&lt;/p&gt;

&lt;p&gt;于是我们有
\(E[I] = \Pr[I = 1]=\sum_{i\geq a}\Pr[X = i]\leq \sum_{i\geq a}\Pr[X = i]\cdot \frac i a = E[X/a] = E[X]/a.\)&lt;/p&gt;

&lt;h4 id=&quot;切比雪夫不等式chebyshevs-inequality&quot;&gt;切比雪夫不等式（Chebyshev’s Inequality）&lt;/h4&gt;

&lt;h5 id=&quot;方差&quot;&gt;方差&lt;/h5&gt;

&lt;p&gt;我们定义方差$\textrm{Var}[X] = E[(X - E[X])^2]$.&lt;/p&gt;

&lt;p&gt;直观地看，一个随机变量越可能远离其期望，其方差越大。&lt;/p&gt;

&lt;h5 id=&quot;切比雪夫不等式&quot;&gt;切比雪夫不等式&lt;/h5&gt;

&lt;p&gt;对于任意的$a &amp;gt; 0$，
\(\Pr[|X-E[X]| \geq a] \leq \textrm{Var}[X]/a^2.\)&lt;/p&gt;

&lt;p&gt;即，随机变量远离其期望超过$a$的概率，随方差线性增加，随 $a$ 二次减少。&lt;/p&gt;

&lt;p&gt;证明：&lt;/p&gt;

&lt;p&gt;\(\Pr(|X - E[X]| \geq a) = \Pr((X - E[X])^2 \geq a^2).\)
利用马尔科夫不等式，有&lt;/p&gt;

\[\Pr((X - E[X])^2 \geq a^2) \leq E[(X - E[X])^2] / a^2 = \textrm{Var}[X] / a^2.\]

&lt;h4 id=&quot;切尔诺夫上界chernoffs-bound&quot;&gt;切尔诺夫上界（Chernoff’s bound）&lt;/h4&gt;

&lt;p&gt;以上两个不等式都是关于一个随机变量的，现在对于多个随机变量（例如连续扔多次硬编的游戏），我们可以限制其远离期望的概率。&lt;/p&gt;

&lt;p&gt;切尔诺夫上界可以被描述为：&lt;/p&gt;

&lt;p&gt;令$X_1, \dots, X_n$为独立的泊松实验&lt;sup id=&quot;fnref:possion&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:possion&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，其满足$\Pr(X_i = 1) = p_i$. 令$X = \sum_{i = 1}^n X_i$且$\mu = E[X].$ 则对于任意的$\delta &amp;gt; 0$，
\(\Pr\left(X\geq\left(1+\delta\right)\mu\right)\leq{\left(\frac{e^\delta}{{\left(1+\delta\right)}^{\left(1+\delta\right)}}\right)}^\mu.\)&lt;/p&gt;

&lt;p&gt;切尔诺夫上界证明了，对于一连串的泊松实验，其结果之和远离其期望的概率会关于远离幅度（$\delta$）和期望大小（$\mu$）指数地下降。&lt;/p&gt;

&lt;p&gt;切尔诺夫上界的证明利用矩母函数（moment generation functions）及其马尔科夫不等式。因时间有限，故在此省略；可参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Chernoff_bound&quot;&gt;证明&lt;/a&gt;。&lt;/p&gt;

&lt;h5 id=&quot;切尔诺夫上界的特殊情况&quot;&gt;切尔诺夫上界的特殊情况&lt;/h5&gt;

&lt;p&gt;对于服从成功概率为$p$的伯努利分布（成功则取值$1$，否则取值为$0$；例如，我们定义的扔硬币即服从成功概率为$0.5$的伯努利分布）的一系列随机变量$X_1, \dots, X_n$，定义$X = \sum_{i = 1}^n X_i$，$\mu = E[X]$，则对于任意的$0 &amp;lt; \delta \leq 1$，有&lt;/p&gt;

\[\Pr[X \geq (1 + \delta)\mu] \leq e^{-\mu\delta^2/3};\]

&lt;p&gt;对于任意的$R&amp;gt;6\mu$，有&lt;/p&gt;

\[\Pr[X \geq R] \leq 2^{-R}.\]

&lt;p&gt;（该二者均可通过原切尔诺夫上界推导出；过程在此省略。）&lt;/p&gt;

&lt;p&gt;例如，连续玩2000次扔硬币游戏，最终收益超过1250元（$\delta = 0.25$）的概率不超过$e^{-1000\times0.25^2/3} &amp;lt;8.96\times 10^{-10}$，该值大约是随机地买一注双色球彩票中一等奖概率的$\frac 1 {63}$。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在本章中我们讨论了关于概率的基本概念，并通过马尔科夫不等式、切比雪夫不等式和切尔诺夫上界知道了随机变量取值远离其期望的概率。有了基本的概念和数学工具，我们将在下一章讨论完全随机地扔$n$个球进$n$个桶里，最后球最多的桶里的球数的期望。&lt;/p&gt;

&lt;h1 id=&quot;二闭着眼睛选一个&quot;&gt;二、闭着眼睛选一个&lt;/h1&gt;

&lt;p&gt;上一章我们以扔硬币为例介绍了概率论中的基本概念，并且证明了本系列文章需要的三个不等式。有了这些基本内容，我们将在本章讨论完全随机地扔$n$个球进$n$个桶里，最后球最多的桶里的球数的期望。&lt;/p&gt;

&lt;p&gt;我们希望限制球数最大的桶的球数，这里我们证明：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;球数最大的桶的球数的期望为$\Omega(\frac {\ln n} {\ln\ln n})$。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们分两个步骤证明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;（期望的上界）存在球数不小于$\frac {3\ln n} {\ln\ln n}$的桶的概率不超过$\frac 1 n$；&lt;/li&gt;
  &lt;li&gt;（期望的下界）存在球数超过$\frac {\ln n} {3\ln\ln n}$的桶的概率超过$1 - \frac 1 {n^{2/3}}$。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;上界的证明&quot;&gt;上界的证明&lt;/h2&gt;

&lt;h3 id=&quot;限制桶i球数太大的概率&quot;&gt;限制桶$i$球数太大的概率&lt;/h3&gt;

&lt;p&gt;利用切尔诺夫上界，这里我们知道对于任意的桶$B_i$，设随机指示器（事件发生时取值为$1$、否则为$0$的随机变量）&lt;/p&gt;

\[X_j^{B_i} = \begin{cases}1, \qquad \text{球}j\text{被扔进}B_i,\\0, \qquad \text{otherwise.}\end{cases}\]

&lt;p&gt;这里$X_j^{B_i}$可以看成是以概率为$1/n$的伯努利实验的结果；取$X^{B_i} = \sum_{j=0}^n X_j^{B_i}$，则$E[X^{B_i}] = 1$，利用切尔诺夫上界，这里令$\delta = \frac {3\ln n}{\ln\ln n} - 1$，记$b = \delta + 1 = \frac {3\ln n} {\ln\ln n}$，有&lt;/p&gt;

\[\Pr(E[X^{B_i}] &amp;gt; b + 1) \leq \frac {e^{b-1}}{b^b} = \frac 1 e(\frac e b)^b = \frac 1 e (\frac {e\ln\ln n}{3\ln n})^b \leq \frac 1 e (\frac{\ln\ln n}{\ln n})^b,\]

&lt;p&gt;这里分别有$e^b = n^{3/\ln\ln n}$ &lt;sup id=&quot;fnref:elnx&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:elnx&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，因为$(\ln\ln n )^b = e^{b\ln\ln\ln n} = n^{3\ln\ln\ln n / \ln\ln n},$&lt;/p&gt;

&lt;p&gt;所以$(\ln n)^b = (\ln n)^{\frac {3\ln n }{\ln\ln n}} = e^{\frac {3\ln n \ln\ln n}{\ln\ln n}} = e^{3\ln n} = n^3$ &lt;sup id=&quot;fnref:xy&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:xy&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，因此$\Pr(E[X^{B_i}] &amp;gt; b + 1) \leq \frac 1 e n^{\frac {3\ln\ln\ln n}{\ln\ln n} - 3}\leq \frac 1 {en^2} \leq 1 / n^2.$&lt;/p&gt;

&lt;h3 id=&quot;union-bound&quot;&gt;Union Bound&lt;/h3&gt;

&lt;p&gt;这里我们引入Union Bound（也称布尔不等式，Boole’s inequality）。该不等式描述的含义为，一系列事件中至少发生一个的概率不超过其单个事件的概率之和。例如，随机从54张牌中抽5张牌，“其中有一对4或者一对9”的概率小于“其中有一对4”的概率加“其中有一对9”的概率——这是因为后者计算了两次“其中有一对4且其中有一对9”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2020-06-28/cards-venn.png&quot; alt=&quot;cards-venn&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正式的表述为：$\Pr(\cup_i X_i) \leq \sum_i\Pr(X_i).$&lt;/p&gt;

&lt;h3 id=&quot;存在球数太大的桶的概率&quot;&gt;存在球数太大的桶的概率&lt;/h3&gt;

&lt;p&gt;我们利用第一小节的结论，即，对于任意的$i\in[n]$，桶$i$的球数超过$\frac {3\ln n} {\ln\ln n}$的概率不超过$1/n^2$，使用第二小节提到的Union Bound，有：&lt;/p&gt;

&lt;p&gt;存在球数超过$\frac {3\ln n} {\ln\ln n}$的桶的概率不超过$\sum_{i = 1}^n 1/n^2 = 1/n.$&lt;/p&gt;

&lt;h3 id=&quot;球最多的桶的球数的期望的上界&quot;&gt;球最多的桶的球数的期望的上界&lt;/h3&gt;

&lt;p&gt;这里我们令$X$代表球最多的桶的球数，令&lt;/p&gt;

\[X&apos; = \begin{cases}\frac {3\ln n} {\ln\ln n}, \qquad X\leq\frac {3\ln n} {\ln\ln n}, \\ n, \qquad\qquad\textrm{otherwise}. \end{cases}\]

&lt;p&gt;显然有$X \leq X’$，因为$X$至多取值到$n.$ 因此，&lt;/p&gt;

\[E[X] \leq E[X&apos;] \leq \frac {3\ln n} {\ln\ln n}\cdot (1 - 1/n) + n \cdot 1/n \leq \frac {3\ln n} {\ln\ln n} + 1.\]

&lt;h2 id=&quot;下界的证明&quot;&gt;下界的证明&lt;/h2&gt;

&lt;p&gt;首先我们设随机指示器变量$X_i$，其值取$1$当且仅当桶$i$的球数不小于$k$（稍后我们确定$k$的值）。则有&lt;/p&gt;

&lt;p&gt;$\Pr(X_i = 1) \geq \frac {n \choose k} {n^k}.$&lt;/p&gt;

&lt;p&gt;这是因为该桶球数不小于$k$的扔球方法里，包括随机选$k$个球扔进该桶$n\choose k$种情况，而这$k$个球的扔法有$n^k$中情况。&lt;/p&gt;

&lt;p&gt;由于对于$n \geq k &amp;gt; i$，有$\frac {n-i}{k-i} \geq \frac n k$，故有${n \choose k} \geq {(\frac n k)}^k$，因此$\Pr(X_i = 1) \geq 1/k^k.$&lt;/p&gt;

&lt;p&gt;这里我们取$k = \frac {\ln n}{3\ln\ln n}.$&lt;/p&gt;

&lt;p&gt;于是有$1/k^k = (n^{-1 + \frac {\ln\ln\ln n - \ln\ln n}{\ln n}})^{\frac 1 3} = 1/\sqrt[3+\varepsilon]n$（计算过程略，与上文的过程类似）；这里$\lim_{n\to\infty}\varepsilon = 0.$&lt;/p&gt;

&lt;p&gt;则我们有$E[X_i] \geq 1/\sqrt[3+\varepsilon]n.$&lt;/p&gt;

&lt;p&gt;记$X = \sum_{i\in[n]}X_i$，则有$E[X] \geq n^{\frac 2 3-\varepsilon}.$&lt;/p&gt;

&lt;p&gt;即，所有桶中我们期望有$n^{\frac 2 3 - \varepsilon}$个桶球数较多。但这并不能证明，$\Pr(X\geq 1) \to 1$，即存在一个桶的球数较多这件事一定会发生。反例：考虑另一随机变量$Y$，它有$1/n^{\frac 1 3}$的概率取值为$n$，其余情况取值为$0$，则我们有$E[Y] = n\cdot 1/n^{\frac 1 3} = n^{\frac 2 3}.$ 但是随着$n$增大，$\Pr(Y\geq 1) \to 0.$&lt;/p&gt;

&lt;p&gt;因此我们需要用到「二阶矩」的分析。这里我们回忆「方差」的概念，对于$\textrm{Var}[X + Y] = \textrm{Var}[X] + \textrm{Var}[Y] + \textrm{Cov}[X, Y].$ 这里$\textrm{Cov}[X, Y]$为随机变量$X, Y$的协方差，其定义为：$\textrm{Cov}[X, Y] = E[(X - E[X])\cdot (Y - E[Y])] = E[XY] - E[X]E[Y].$ 这里我们看到，如果一个随机变量在大于其期望的时候另一个也大于其期望，则协方差为正，否则为负。&lt;/p&gt;

&lt;p&gt;回到我们的论述，我们现在可以得到$\textrm{Var}[X] = \sum_{i\in [n]}\textrm{Var}[X_i] + \sum_{i \neq j}\textrm{Cov}[X_i, X_j].$ 这里，我们的直观告诉我们，桶$i$球数较多时，会隐含着桶$j$的球数不会太多，因为两个不同的桶在“争抢”固定的球。因此，$X_i$在大于其期望，即取值为$1$时，$X_j$会更可能小于其期望，即取值为$0$。故，$\textrm{Var}[X] \leq \sum_{i\in[n]}\textrm{Var}[X_i].$&lt;/p&gt;

&lt;p&gt;而此时，$\textrm{Var}[X_i] = E[X_i^2] - E[X_i]^2$，由于$X_i$是随机指示器变量，故$E[X_i^2] = E[X_i]$，因此$\textrm{Var}[X_i] \leq E[X_i].$&lt;/p&gt;

&lt;p&gt;利用切比雪夫不等式，记$\mu = E[X] \geq n^{\frac 2 3-\varepsilon}$，有&lt;/p&gt;

\[\Pr(X = 0) \leq \Pr(|X - \mu|\leq \mu) \leq \frac {\textrm{Var}[X]} {\mu^2} \leq \frac {\sum_{i\in[n]}\textrm{Var}[X_i]} {\mu^2}\leq \frac {n^{2/3 - \varepsilon}}{\mu^2} \leq 1/n^{2/3}.\]

&lt;p&gt;因此$\Pr(X \geq 1) = 1 - \Pr(X = 0) \geq 1 - n^{2/3}.$&lt;/p&gt;

&lt;p&gt;故，我们扔完$n$个球后，以很高的概率会有存在球数达到$\frac {\ln n} {3\ln\ln n}$的桶。&lt;/p&gt;

&lt;p&gt;利用与上文类似的分析桶最大球数期望的方法我们可以知道该期望的下界为$\frac {\ln n} {3\ln\ln n} - 1.$&lt;/p&gt;

&lt;p&gt;经过分析我们发现，完全随机地向$n$个桶里扔$n$个球，最后球最多的桶的球数之期望为$\Omega(\frac {\ln n} {\ln\ln n})$，并且以很高的概率，该数值在$\frac {\ln n} {3\ln\ln n}$到$\frac {3\ln n} {\ln\ln n}$之间。&lt;/p&gt;

&lt;p&gt;这个结论是出人意料的，因为我们知道每个桶里球数的期望其实是$1$，而这里最大负载很大概率居然是期望的$\Omega(\frac {\ln n} {\ln\ln n})$倍！&lt;/p&gt;

&lt;p&gt;这告诉我们在负载均衡场景中，单纯使用随机的方法分配请求是不够好的。那么我们能否做得更好？接下来我们继续深入。&lt;/p&gt;

&lt;h1 id=&quot;三闭着眼睛选两个再瞅一眼&quot;&gt;三、闭着眼睛选两个，再瞅一眼！&lt;/h1&gt;

&lt;p&gt;在上一章中我们讨论了随机地把$n$个球扔进$n$个桶里后负载最大的桶的球数的期望——$\Omega(\frac {\ln n } {\ln\ln n})$；在本章中，我们将讨论一个看似微小的改进：每次随机选择两个桶，把球扔进这两个桶中负载最小的桶里；我们将说明，最终负载最大的桶的球数的期望将有指数级的下降。&lt;/p&gt;

&lt;p&gt;仅仅多挑一个桶，结果就有指数级的下降——实际上，每次随机选$d$个桶，把球扔进这两个桶中负载最小的桶里，最终的最大负载以很高的概率不会超过$\frac {\ln\ln n} {\ln d} + O(1)$；证明可以参考Michael Mitzenmacher的&lt;a href=&quot;https://www.eecs.harvard.edu/~michaelm/postscripts/mythesis.pdf&quot;&gt;博士论文&lt;/a&gt;的第1.2节；由于证明需要非常细致地对条件概率进行处理，我们在本章中仅介绍证明的思路，且限制$d = 2$。&lt;/p&gt;

&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;我们将定义如下术语：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在时刻$t$：刚扔出第$t$个球时；&lt;/li&gt;
  &lt;li&gt;时刻$t$前：扔完第$t-1$个球后，扔第$t$个球之前&lt;/li&gt;
  &lt;li&gt;时刻$t$后：刚扔出第$t$个球后；&lt;/li&gt;
  &lt;li&gt;$\omega_t$：$t$时刻扔出的球所落的桶；这里，$(\omega_1, \dots, \omega_n)$决定了整个扔球过程；&lt;/li&gt;
  &lt;li&gt;球的高度：球被扔进桶里时，除该球外桶里的球的数量加$1$；&lt;/li&gt;
  &lt;li&gt;记$\beta_i$表示在时刻$n$后球数超过$i$的桶的数量的&lt;strong&gt;上界&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将定义如下随机变量：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\#Bin_i(t)$表示时刻$t$后负载不小于$i$的桶的数量；&lt;/li&gt;
  &lt;li&gt;$\#Ball_i(t)$表示时刻$t$后高度不小于$i$的球的数量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;显然，负载不小于$i$的桶里至少存在$1$个高度为$i$的球，故$\#Ball_i(t) \geq \#Bin_i (t).$&lt;/p&gt;

&lt;h2 id=&quot;证明思路&quot;&gt;证明思路&lt;/h2&gt;

&lt;p&gt;我们利用$\beta_1, \dots, \beta_k$来限制负载过大的桶的数量，而这些值我们通过归纳法得到——当我们扔出一个高度不小于$i+1$的球的时候，一定是随机挑到了两个负载不小于$i$的桶。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2020-06-28/beta_i.png&quot; alt=&quot;beta_i&quot; /&gt;&lt;/p&gt;

&lt;p&gt;利用归纳法，当$\#Bin_i(n) \leq \beta_i$时，在扔任意球的时候我们都有：扔出该球的高度大于$i$的概率最多为：$p_i = (\frac {\beta_i} n)^2.$ 因此在整个过程中，高度大于$i$的球的数量的期望最多为$np_i$。于是，我们可以设$\beta_{i + 1} = np_i = \frac {\beta_i^2} n.$&lt;/p&gt;

&lt;p&gt;我们可以以某个$i$开始限制$\beta_i$，例如我们有$\beta_2\leq n/2$（鸽笼原理）。现在递推，可以知道$\beta_{i + 2} = \frac n {2^{2^i}}.$&lt;/p&gt;

&lt;p&gt;因此，设$i = \log\log n + O(1)$，有$\beta_{i + 2} &amp;lt; 1.$&lt;/p&gt;

&lt;p&gt;这样就证明了数量超过$\log\log n$的桶的数量的期望小于1。&lt;/p&gt;

&lt;h2 id=&quot;多看一眼的神奇之处&quot;&gt;多看一眼的神奇之处&lt;/h2&gt;

&lt;p&gt;为什么每次从闭着眼睛随机选一个桶来扔球，到每次挑选两个桶扔进负载较小的一个桶里，我们的最大负载有了指数级的下降？答案当然可以是：详见证明。但真正给我们的直观是，多了关于桶负载的“信息”——这也能某种程度上说明，每次挑选$d$个桶时，$d = 1$和$d = 2$有本质的区别（指数倍下降），而$d = 2$和$d = O(1)$没有本质的区别（常数倍下降）。&lt;/p&gt;

&lt;p&gt;指数级的负载下降。那么，我的朋友，代价是什么呢？&lt;/p&gt;

&lt;p&gt;$d = 1$与$d &amp;gt; 1$的区别是RTT，球需要发起一轮询问并接收一轮消息。信息的传递使得最终的负载有了指数级的下降。&lt;/p&gt;

&lt;h1 id=&quot;四进一步的结论&quot;&gt;四、进一步的结论&lt;/h1&gt;

&lt;p&gt;我们已经讨论了静态模型（逐个地扔球进桶）中扔$n$个球进$n$个桶的情况，每次随机挑两个桶的方法比起完全随机扔球会有指数级的最大负载下降。在本章中我们会介绍当球数远大于桶数时的结果，以及其他模型下的结论。&lt;/p&gt;

&lt;p&gt;在本章的讨论中，我们记球数为$m$，记桶数为$n.$&lt;/p&gt;

&lt;h2 id=&quot;静态模型下随机扔m-n个球&quot;&gt;静态模型下随机扔$m » n$个球&lt;/h2&gt;

&lt;p&gt;在前两章的讨论中，为了分析的简便，我们都是假设$m = n$；证明也可以容易地扩展到$m = n\log n$的情况。但当球数多项式倍于桶数的时候，即$m = \textrm{poly}(n)$时，证明将变得复杂起来——而这恰恰是负载均衡话题中通常会讨论到的情况——请求数量远多于服务器的数量。&lt;/p&gt;

&lt;p&gt;我们下面介绍Raab和Steger关于完全随机扔球进桶的&lt;a href=&quot;https://rd.springer.com/chapter/10.1007/3-540-49543-6_13&quot;&gt;工作&lt;/a&gt;和Berenbrink等人在STOC 2000的&lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/335305.335411&quot;&gt;工作&lt;/a&gt;；Talwar和Wieder在ICALP 2014给出了与后者同样的结论但证明更简化的&lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-3-662-43948-7_81&quot;&gt;版本&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在我们的模型中，我们定义随机变量$Gap$为扔完$m$个球进$n$个桶后，负载最大的桶的球数与桶里球数的期望之差。例如，我们前两章讨论的$n = m$结果，对于完全随机扔球进桶，$E[Gap] = \Omega(\frac {\ln n } {\ln\ln n}) - 1 = \Omega(\frac {\ln n } {\ln\ln n})$；而随机挑两个桶扔进负载较小的桶里，我们有$E[Gap] = \Omega(\ln\ln n) - 1 = \Omega(\ln\ln n).$&lt;/p&gt;

&lt;p&gt;Raab和Steger证明了，对于$m &amp;gt; \frac n {\textrm{polylog}(n)}$，完全随机扔球进桶的情况是以很高的概率：&lt;/p&gt;

\[Gap = \Omega(\sqrt{\frac {m\log n}{n}}).\]

&lt;p&gt;而Berenbrink等人证明了，对于任意的$m$，每次随机选$d&amp;gt;1$个桶并扔球进负载较低的桶里，有：&lt;/p&gt;

\[E[Gap] \leq \frac {\log\log n}{\log d} + O(\log\log\log n).\]

&lt;p&gt;注意，这里每次挑两个桶的$Gap$的期望&lt;strong&gt;与球数不再相关&lt;/strong&gt;！即使$m = 2^n$，最后$Gap$的期望也仍然只有$O(\log\log n)$！&lt;/p&gt;

&lt;h2 id=&quot;动态模型&quot;&gt;动态模型&lt;/h2&gt;

&lt;p&gt;现在我们考虑这样的“超市模型”（supermarket model）——超市有$n$个收银台，每个收银台给顾客结账的时间服从均值为$1$的指数分布，顾客的到来服从参数为$\lambda n$的泊松过程（$0 &amp;lt; \lambda &amp;lt; 1$）（可以简单理解为任意两个顾客到达收银台的间隔的期望是$\frac 1 {\lambda n}$，即每单位时间收银台前会新增$\lambda n$个顾客），每个收银台遵循FIFO的规则为顾客结账。假设每个顾客抵达收银台时随机选择$d$个收银台，并前往其中负载最小的收银台排队等候。如图，顾客A选择随机选两条队列，然后排到其中长度较小的那一个中；顾客B刚被服务，已经离开收银台。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2020-06-28/supermarket.png&quot; alt=&quot;supermarket&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这一超市模型在某种程度上符合现实中的负载均衡情况。Michael Mitzenmacher在其博士论文中讨论了该情况，由于分析十分复杂，我们也仅介绍结论：&lt;/p&gt;

&lt;p&gt;队列初始都为空的情况下，对于任意的$T &amp;gt; 0$，对于$d&amp;gt;2$，在时间段$[0, T]$中队伍长度的最大值以很高的概率为$\frac {\log\log n} {\log d} + O(1).$&lt;/p&gt;

&lt;p&gt;即，我们在动态模型中得到了静态模型类似的结论，只要该过程每时刻到达收银台的顾客数的期望不超过收银台的数量，那么任意时间段内队伍的最大长度都只会是$\Omega(\log\log n)$！&lt;/p&gt;

&lt;p&gt;甚至我们可以&lt;a href=&quot;http://www.eecs.harvard.edu/~michaelm/postscripts/handbook2001.pdf&quot;&gt;扩展&lt;/a&gt;：高优先级的请求（出现概率为$p$）随机挑两个服务器并进入负载较低的服务器排队，而低优先级的请求（出现概率为$1-p$）完全随机地挑选一个服务器；请求的出现仍然服从参数为$\lambda n$的泊松过程，在$\lambda = 0.99$时我们可以画出图像：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/2020-06-28/ratio-2-choices.png&quot; alt=&quot;2 choices&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看见，只要有一小部分任务“选两个再多瞅一眼”，就能显著降低队列长度的期望。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;我们在这一系列的文章中介绍了概率的几个基本概念与基本不等式，并应用它们尝试解决扔$n$个球进$n$个桶游戏中最大负载的桶的球数的期望，我们发现：每次随机挑选两个桶并将球扔进负载较低的桶里，比起完全随机挑选一个桶再扔进去有了指数级的负载降低，即从$\Omega(\frac {\log n} {\log\log n})$降低到$O(\log\log n).$ 我们进一步介绍了当球数远多于桶数时，随机挑两个的结果使得最大负载与平均负载的差值（$Gap$）与球数不再相关，以及动态模型中随机挑两个的策略也可以得到和静态模型中相似的结果。&lt;/p&gt;

&lt;p&gt;我们认为其背后的哲学在于，随机挑两个球的模型是因为其知道了桶里球分布的信息，使得最终结果有了指数级的提升。但其代价在于，信息的传递需要时间。在最后我们也介绍了，只有一部分球随机选两个的动态模型，最终的结果也能有很大的提升。&lt;/p&gt;

&lt;p&gt;当然在现实中我们不期望负载均衡是完全符合我们的假设，例如请求的到来服从泊松分布、每台服务器的性能相同、每个请求的完成时间的期望相同，但是对于这样理论情况的分析还是可以一定程度上指导我们的算法。希望这一系列的文章对你有所帮助。&lt;/p&gt;

&lt;p&gt;感谢阅读！&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Mitzenmacher M, Upfal E. &lt;em&gt;Probability and computing: Randomization and probabilistic techniques in algorithms and data analysis&lt;/em&gt;. Cambridge university press, 2017.&lt;/li&gt;
  &lt;li&gt;Gupta A. &lt;em&gt;&lt;a href=&quot;http://www.cs.cmu.edu/~avrim/Randalgs11/lectures/lect0202.pdf&quot;&gt;Lec 8: Balls and Bins/Two Choices&lt;/a&gt;&lt;/em&gt;, Lecture Notes, &lt;em&gt;15-859M: Randomized Algorithms&lt;/em&gt;, Carnegie Mellon University.&lt;/li&gt;
  &lt;li&gt;Mitzenmacher, Michael David. &lt;em&gt;The power of two random choices in randomized load balancing&lt;/em&gt;. Diss. PhD thesis, Graduate Division of the University of California at Berkley, 1996.&lt;/li&gt;
  &lt;li&gt;Berenbrink, Petra, et al. “Balanced allocations: the heavily loaded case.” &lt;em&gt;Proceedings of the thirty-second annual ACM symposium on Theory of computing&lt;/em&gt;. 2000.&lt;/li&gt;
  &lt;li&gt;Talwar, Kunal, and Udi Wieder. “Balanced allocations: A simple proof for the heavily loaded case.” &lt;em&gt;International Colloquium on Automata, Languages, and Programming&lt;/em&gt;. Springer, Berlin, Heidelberg, 2014.&lt;/li&gt;
  &lt;li&gt;Raab, Martin, and Angelika Steger. “Balls into bins”—A simple and tight analysis. &lt;em&gt;International Workshop on Randomization and Approximation Techniques in Computer Science&lt;/em&gt;. Springer, Berlin, Heidelberg, 1998.&lt;/li&gt;
  &lt;li&gt;Richa, Andrea W., M. Mitzenmacher, and R. Sitaraman. “The power of two random choices: A survey of techniques and results.” &lt;em&gt;Combinatorial Optimization&lt;/em&gt; 9 (2001): 255-304.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:possion&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;存在$0\leq p_i \leq 1$使得$X_i$以$p_i$的概率使得$X_i = 1$，以$(1-p_i)$的概率使得$X_i = 0$。 &lt;a href=&quot;#fnref:possion&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:elnx&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;这里我们使用了$e^{\ln x} = x.$ &lt;a href=&quot;#fnref:elnx&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:xy&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;这里我们使用了$x^y = (e^{\ln x})^y.$ &lt;a href=&quot;#fnref:xy&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Wenxing Lai</name><email>wenxing.lai@outlook.com</email></author><category term="Probability" /><category term="Fun" /><summary type="html">同事介绍负载均衡算法时透露，其原B站leader透露说B站的负载均衡算法是基于一篇对扔球进桶问题讨论的论文。正好笔者曾看过相关内容，也深感这一简单的概率游戏有着让人意外的结果，故希望写一系列的文章，介绍这一简单而优美的结果。本篇文章为该系列文章的集合。 在服务器的负载均衡模型中，我们可以把负载均衡看作是“扔球进桶”的游戏——我们的目标即最小化含有球数量最高的桶里的球的数量。在讨论中，有三种模型： 静态模型：把球一个一个地扔进桶里（扔第$i$个球时，前$i-1$个球被扔进了哪里是已经确定的）； 并行化模型：所有的球同时扔进桶里（扔球没有顺序关系）； 动态模型：球按一定规律随时间到来，每个桶按一定的速度消耗掉球。 其中，动态模型最接近真实情况。为简便起见，我们将在本系列文章中详细讨论把$n$个球扔进$n$个桶的静态模型，并介绍更接近于真实负载均衡场景的静态模型中球数多项式倍于桶数的情况与其他模型的结论。 我们希望详细讨论的问题有两个： 完全随机地扔$n$个球进$n$个桶里，最后球最多的桶里的球数的期望是多少？ 扔$n$个球进$n$个桶里，每次完全随机地挑两个桶，把球扔进球数较少的桶里，最后的结果有怎样的改变？ 一、远离期望 意料之外与情理之中：生日问题 假设所有人的生日为365天之中的其中一天，且机会均等。 当优图实验室有多少人时，我们可以保证有两人的生日是在同一天？ 随机选取$n$人，估计这$n$人中存在两人生日是在同一天的概率大致是以下数字中的哪一个： $n = 7$ $n = 23$ $n = 60$ $n = 183$ \(0.01\%, 1\%, 5\%, 25\%, 50\%, 90\%, 99.9999\%\) 对于第一题，根据鸽笼原理，答案是$366$人。 对于第二题，结果可能出人意料： $n = 7,\ 5.23\%$ $n = 23,\ 50.72\%$ $n = 60,\ 99.41\%$ $n = 183,\ \sim 1-{10}^{24}$ 其计算方法是： 当有$n$人时，不存在两人生日在同一天的情况有 $b(n) = {365 \choose n} \cdot n!$ 种，而$n$人生日的所有情况有$365^n$种。因此，存在两人生日在同一天的“概率”为： \(\Pr(\textrm{ex. 2 people who have the same birthday}) = 1-b(n)/365^n,\) 可画出图如下： 随机变量、期望，以及远离期望 在本节中，我们将介绍概率论中的几个基本概念，以及在讨论中会使用到的几个不等式。在讨论中，我们都以扔硬币游戏为例。 在这里我们不严格定义概率和概率空间；我们可以称“概率”，是指样本空间$\Omega$（随机过程中可能的结果）中允许的“事件”由概率函数$\Pr$得到的数值；这里，概率函数的值域为1，且$\Pr(\Omega) = 1$，且对于彼此独立的事件$E_1, \dots$有$\Pr(\cup_{i\geq 1} E_i) = \sum_{i \geq 1} \Pr(E_i)$。 例如扔一枚均匀的硬币，样本空间为$\Omega = {\textrm{Head, Tail}}$，允许的事件即为正面朝上（Head）与反面朝上（Tail），而概率函数选择为： \[\Pr(E) = \begin{cases}0.5,\qquad E = \textrm{Head,}\\ 0.5, \qquad E = \textrm{Tail.} \end{cases}\] 随机变量 随机变量$X$是将样本空间映射到实数值的函数，即$X: \Omega \to R$. 与概率函数不同，随机变量无需具有概率函数的三性质。 例如，在扔硬币游戏中，我们定义$X$为： \[X = \begin{cases}1,\qquad E = \textrm{Head},\\0, \qquad E = \textrm{Tail}.\end{cases}\] 该随机变量即描述了扔一枚均匀的硬币，扔出正面获得$1$元，否则获得$0$元的规则。 数学期望 假设扔一枚均匀的硬币，扔出正面获得$1$元，否则获得$0$元。玩一次该游戏，我们期望能有多少受益？ 我们的直观告诉我们，我们期望收益是$0.5$元。 随机变量$X$的数学期望也是按这样的思路定义： $E[X] = \sum_i i\cdot \Pr(X = i)$. 因此我们可以计算，玩一次扔硬币游戏的期望是： $E[X] = 1\times 0.5 + 0\times 0.5 = 0.5$. 容易证明，数学期望具有线性，即$E[aX + bY] = aE[X] + bE[Y]$. 远离数学期望的概率 我们继续扔硬币游戏，假设连续玩$n$次（其随机变量分别定义为$X_1, \dots, X_n$），我们定义$X = X_1 + \dots + X_n$，则$X$的期望是多少？ $E[X] = E[\sum_{i=1}^n X_i] = \sum_{i=1}^n E[X_i] = 0.5n$. 但是仍然有可能，我们的收益远少于$0.5n$（例如连续扔出$n$次反面），因此我们想要限制随机变量的值远离其期望的概率。 马尔科夫不等式（Markov Inequality） 对于取值非负的随机变量$X$，对于任意的$a&amp;gt;0$，有 \(\Pr(X\geq a)\leq E[X]/a.\) 证明： 当$a &amp;gt; 0$，令 \(I=\begin{cases}1,\qquad X\geq a\\ 0,\qquad \textrm{otherwise.}\end{cases}\) 则根据$I$的定义，有$I \leq X/a$。 于是我们有 \(E[I] = \Pr[I = 1]=\sum_{i\geq a}\Pr[X = i]\leq \sum_{i\geq a}\Pr[X = i]\cdot \frac i a = E[X/a] = E[X]/a.\) 切比雪夫不等式（Chebyshev’s Inequality） 方差 我们定义方差$\textrm{Var}[X] = E[(X - E[X])^2]$. 直观地看，一个随机变量越可能远离其期望，其方差越大。 切比雪夫不等式 对于任意的$a &amp;gt; 0$， \(\Pr[|X-E[X]| \geq a] \leq \textrm{Var}[X]/a^2.\) 即，随机变量远离其期望超过$a$的概率，随方差线性增加，随 $a$ 二次减少。 证明： \(\Pr(|X - E[X]| \geq a) = \Pr((X - E[X])^2 \geq a^2).\) 利用马尔科夫不等式，有 \[\Pr((X - E[X])^2 \geq a^2) \leq E[(X - E[X])^2] / a^2 = \textrm{Var}[X] / a^2.\] 切尔诺夫上界（Chernoff’s bound） 以上两个不等式都是关于一个随机变量的，现在对于多个随机变量（例如连续扔多次硬编的游戏），我们可以限制其远离期望的概率。 切尔诺夫上界可以被描述为： 令$X_1, \dots, X_n$为独立的泊松实验1，其满足$\Pr(X_i = 1) = p_i$. 令$X = \sum_{i = 1}^n X_i$且$\mu = E[X].$ 则对于任意的$\delta &amp;gt; 0$， \(\Pr\left(X\geq\left(1+\delta\right)\mu\right)\leq{\left(\frac{e^\delta}{{\left(1+\delta\right)}^{\left(1+\delta\right)}}\right)}^\mu.\) 切尔诺夫上界证明了，对于一连串的泊松实验，其结果之和远离其期望的概率会关于远离幅度（$\delta$）和期望大小（$\mu$）指数地下降。 切尔诺夫上界的证明利用矩母函数（moment generation functions）及其马尔科夫不等式。因时间有限，故在此省略；可参考证明。 切尔诺夫上界的特殊情况 对于服从成功概率为$p$的伯努利分布（成功则取值$1$，否则取值为$0$；例如，我们定义的扔硬币即服从成功概率为$0.5$的伯努利分布）的一系列随机变量$X_1, \dots, X_n$，定义$X = \sum_{i = 1}^n X_i$，$\mu = E[X]$，则对于任意的$0 &amp;lt; \delta \leq 1$，有 \[\Pr[X \geq (1 + \delta)\mu] \leq e^{-\mu\delta^2/3};\] 对于任意的$R&amp;gt;6\mu$，有 \[\Pr[X \geq R] \leq 2^{-R}.\] （该二者均可通过原切尔诺夫上界推导出；过程在此省略。） 例如，连续玩2000次扔硬币游戏，最终收益超过1250元（$\delta = 0.25$）的概率不超过$e^{-1000\times0.25^2/3} &amp;lt;8.96\times 10^{-10}$，该值大约是随机地买一注双色球彩票中一等奖概率的$\frac 1 {63}$。 在本章中我们讨论了关于概率的基本概念，并通过马尔科夫不等式、切比雪夫不等式和切尔诺夫上界知道了随机变量取值远离其期望的概率。有了基本的概念和数学工具，我们将在下一章讨论完全随机地扔$n$个球进$n$个桶里，最后球最多的桶里的球数的期望。 二、闭着眼睛选一个 上一章我们以扔硬币为例介绍了概率论中的基本概念，并且证明了本系列文章需要的三个不等式。有了这些基本内容，我们将在本章讨论完全随机地扔$n$个球进$n$个桶里，最后球最多的桶里的球数的期望。 我们希望限制球数最大的桶的球数，这里我们证明： 球数最大的桶的球数的期望为$\Omega(\frac {\ln n} {\ln\ln n})$。 我们分两个步骤证明： （期望的上界）存在球数不小于$\frac {3\ln n} {\ln\ln n}$的桶的概率不超过$\frac 1 n$； （期望的下界）存在球数超过$\frac {\ln n} {3\ln\ln n}$的桶的概率超过$1 - \frac 1 {n^{2/3}}$。 上界的证明 限制桶$i$球数太大的概率 利用切尔诺夫上界，这里我们知道对于任意的桶$B_i$，设随机指示器（事件发生时取值为$1$、否则为$0$的随机变量） \[X_j^{B_i} = \begin{cases}1, \qquad \text{球}j\text{被扔进}B_i,\\0, \qquad \text{otherwise.}\end{cases}\] 这里$X_j^{B_i}$可以看成是以概率为$1/n$的伯努利实验的结果；取$X^{B_i} = \sum_{j=0}^n X_j^{B_i}$，则$E[X^{B_i}] = 1$，利用切尔诺夫上界，这里令$\delta = \frac {3\ln n}{\ln\ln n} - 1$，记$b = \delta + 1 = \frac {3\ln n} {\ln\ln n}$，有 \[\Pr(E[X^{B_i}] &amp;gt; b + 1) \leq \frac {e^{b-1}}{b^b} = \frac 1 e(\frac e b)^b = \frac 1 e (\frac {e\ln\ln n}{3\ln n})^b \leq \frac 1 e (\frac{\ln\ln n}{\ln n})^b,\] 这里分别有$e^b = n^{3/\ln\ln n}$ 2，因为$(\ln\ln n )^b = e^{b\ln\ln\ln n} = n^{3\ln\ln\ln n / \ln\ln n},$ 所以$(\ln n)^b = (\ln n)^{\frac {3\ln n }{\ln\ln n}} = e^{\frac {3\ln n \ln\ln n}{\ln\ln n}} = e^{3\ln n} = n^3$ 3，因此$\Pr(E[X^{B_i}] &amp;gt; b + 1) \leq \frac 1 e n^{\frac {3\ln\ln\ln n}{\ln\ln n} - 3}\leq \frac 1 {en^2} \leq 1 / n^2.$ Union Bound 这里我们引入Union Bound（也称布尔不等式，Boole’s inequality）。该不等式描述的含义为，一系列事件中至少发生一个的概率不超过其单个事件的概率之和。例如，随机从54张牌中抽5张牌，“其中有一对4或者一对9”的概率小于“其中有一对4”的概率加“其中有一对9”的概率——这是因为后者计算了两次“其中有一对4且其中有一对9”。 正式的表述为：$\Pr(\cup_i X_i) \leq \sum_i\Pr(X_i).$ 存在球数太大的桶的概率 我们利用第一小节的结论，即，对于任意的$i\in[n]$，桶$i$的球数超过$\frac {3\ln n} {\ln\ln n}$的概率不超过$1/n^2$，使用第二小节提到的Union Bound，有： 存在球数超过$\frac {3\ln n} {\ln\ln n}$的桶的概率不超过$\sum_{i = 1}^n 1/n^2 = 1/n.$ 球最多的桶的球数的期望的上界 这里我们令$X$代表球最多的桶的球数，令 \[X&apos; = \begin{cases}\frac {3\ln n} {\ln\ln n}, \qquad X\leq\frac {3\ln n} {\ln\ln n}, \\ n, \qquad\qquad\textrm{otherwise}. \end{cases}\] 显然有$X \leq X’$，因为$X$至多取值到$n.$ 因此， \[E[X] \leq E[X&apos;] \leq \frac {3\ln n} {\ln\ln n}\cdot (1 - 1/n) + n \cdot 1/n \leq \frac {3\ln n} {\ln\ln n} + 1.\] 下界的证明 首先我们设随机指示器变量$X_i$，其值取$1$当且仅当桶$i$的球数不小于$k$（稍后我们确定$k$的值）。则有 $\Pr(X_i = 1) \geq \frac {n \choose k} {n^k}.$ 这是因为该桶球数不小于$k$的扔球方法里，包括随机选$k$个球扔进该桶$n\choose k$种情况，而这$k$个球的扔法有$n^k$中情况。 由于对于$n \geq k &amp;gt; i$，有$\frac {n-i}{k-i} \geq \frac n k$，故有${n \choose k} \geq {(\frac n k)}^k$，因此$\Pr(X_i = 1) \geq 1/k^k.$ 这里我们取$k = \frac {\ln n}{3\ln\ln n}.$ 于是有$1/k^k = (n^{-1 + \frac {\ln\ln\ln n - \ln\ln n}{\ln n}})^{\frac 1 3} = 1/\sqrt[3+\varepsilon]n$（计算过程略，与上文的过程类似）；这里$\lim_{n\to\infty}\varepsilon = 0.$ 则我们有$E[X_i] \geq 1/\sqrt[3+\varepsilon]n.$ 记$X = \sum_{i\in[n]}X_i$，则有$E[X] \geq n^{\frac 2 3-\varepsilon}.$ 即，所有桶中我们期望有$n^{\frac 2 3 - \varepsilon}$个桶球数较多。但这并不能证明，$\Pr(X\geq 1) \to 1$，即存在一个桶的球数较多这件事一定会发生。反例：考虑另一随机变量$Y$，它有$1/n^{\frac 1 3}$的概率取值为$n$，其余情况取值为$0$，则我们有$E[Y] = n\cdot 1/n^{\frac 1 3} = n^{\frac 2 3}.$ 但是随着$n$增大，$\Pr(Y\geq 1) \to 0.$ 因此我们需要用到「二阶矩」的分析。这里我们回忆「方差」的概念，对于$\textrm{Var}[X + Y] = \textrm{Var}[X] + \textrm{Var}[Y] + \textrm{Cov}[X, Y].$ 这里$\textrm{Cov}[X, Y]$为随机变量$X, Y$的协方差，其定义为：$\textrm{Cov}[X, Y] = E[(X - E[X])\cdot (Y - E[Y])] = E[XY] - E[X]E[Y].$ 这里我们看到，如果一个随机变量在大于其期望的时候另一个也大于其期望，则协方差为正，否则为负。 回到我们的论述，我们现在可以得到$\textrm{Var}[X] = \sum_{i\in [n]}\textrm{Var}[X_i] + \sum_{i \neq j}\textrm{Cov}[X_i, X_j].$ 这里，我们的直观告诉我们，桶$i$球数较多时，会隐含着桶$j$的球数不会太多，因为两个不同的桶在“争抢”固定的球。因此，$X_i$在大于其期望，即取值为$1$时，$X_j$会更可能小于其期望，即取值为$0$。故，$\textrm{Var}[X] \leq \sum_{i\in[n]}\textrm{Var}[X_i].$ 而此时，$\textrm{Var}[X_i] = E[X_i^2] - E[X_i]^2$，由于$X_i$是随机指示器变量，故$E[X_i^2] = E[X_i]$，因此$\textrm{Var}[X_i] \leq E[X_i].$ 利用切比雪夫不等式，记$\mu = E[X] \geq n^{\frac 2 3-\varepsilon}$，有 \[\Pr(X = 0) \leq \Pr(|X - \mu|\leq \mu) \leq \frac {\textrm{Var}[X]} {\mu^2} \leq \frac {\sum_{i\in[n]}\textrm{Var}[X_i]} {\mu^2}\leq \frac {n^{2/3 - \varepsilon}}{\mu^2} \leq 1/n^{2/3}.\] 因此$\Pr(X \geq 1) = 1 - \Pr(X = 0) \geq 1 - n^{2/3}.$ 故，我们扔完$n$个球后，以很高的概率会有存在球数达到$\frac {\ln n} {3\ln\ln n}$的桶。 利用与上文类似的分析桶最大球数期望的方法我们可以知道该期望的下界为$\frac {\ln n} {3\ln\ln n} - 1.$ 经过分析我们发现，完全随机地向$n$个桶里扔$n$个球，最后球最多的桶的球数之期望为$\Omega(\frac {\ln n} {\ln\ln n})$，并且以很高的概率，该数值在$\frac {\ln n} {3\ln\ln n}$到$\frac {3\ln n} {\ln\ln n}$之间。 这个结论是出人意料的，因为我们知道每个桶里球数的期望其实是$1$，而这里最大负载很大概率居然是期望的$\Omega(\frac {\ln n} {\ln\ln n})$倍！ 这告诉我们在负载均衡场景中，单纯使用随机的方法分配请求是不够好的。那么我们能否做得更好？接下来我们继续深入。 三、闭着眼睛选两个，再瞅一眼！ 在上一章中我们讨论了随机地把$n$个球扔进$n$个桶里后负载最大的桶的球数的期望——$\Omega(\frac {\ln n } {\ln\ln n})$；在本章中，我们将讨论一个看似微小的改进：每次随机选择两个桶，把球扔进这两个桶中负载最小的桶里；我们将说明，最终负载最大的桶的球数的期望将有指数级的下降。 仅仅多挑一个桶，结果就有指数级的下降——实际上，每次随机选$d$个桶，把球扔进这两个桶中负载最小的桶里，最终的最大负载以很高的概率不会超过$\frac {\ln\ln n} {\ln d} + O(1)$；证明可以参考Michael Mitzenmacher的博士论文的第1.2节；由于证明需要非常细致地对条件概率进行处理，我们在本章中仅介绍证明的思路，且限制$d = 2$。 准备工作 我们将定义如下术语： 在时刻$t$：刚扔出第$t$个球时； 时刻$t$前：扔完第$t-1$个球后，扔第$t$个球之前 时刻$t$后：刚扔出第$t$个球后； $\omega_t$：$t$时刻扔出的球所落的桶；这里，$(\omega_1, \dots, \omega_n)$决定了整个扔球过程； 球的高度：球被扔进桶里时，除该球外桶里的球的数量加$1$； 记$\beta_i$表示在时刻$n$后球数超过$i$的桶的数量的上界。 我们将定义如下随机变量： $\#Bin_i(t)$表示时刻$t$后负载不小于$i$的桶的数量； $\#Ball_i(t)$表示时刻$t$后高度不小于$i$的球的数量。 显然，负载不小于$i$的桶里至少存在$1$个高度为$i$的球，故$\#Ball_i(t) \geq \#Bin_i (t).$ 证明思路 我们利用$\beta_1, \dots, \beta_k$来限制负载过大的桶的数量，而这些值我们通过归纳法得到——当我们扔出一个高度不小于$i+1$的球的时候，一定是随机挑到了两个负载不小于$i$的桶。 利用归纳法，当$\#Bin_i(n) \leq \beta_i$时，在扔任意球的时候我们都有：扔出该球的高度大于$i$的概率最多为：$p_i = (\frac {\beta_i} n)^2.$ 因此在整个过程中，高度大于$i$的球的数量的期望最多为$np_i$。于是，我们可以设$\beta_{i + 1} = np_i = \frac {\beta_i^2} n.$ 我们可以以某个$i$开始限制$\beta_i$，例如我们有$\beta_2\leq n/2$（鸽笼原理）。现在递推，可以知道$\beta_{i + 2} = \frac n {2^{2^i}}.$ 因此，设$i = \log\log n + O(1)$，有$\beta_{i + 2} &amp;lt; 1.$ 这样就证明了数量超过$\log\log n$的桶的数量的期望小于1。 多看一眼的神奇之处 为什么每次从闭着眼睛随机选一个桶来扔球，到每次挑选两个桶扔进负载较小的一个桶里，我们的最大负载有了指数级的下降？答案当然可以是：详见证明。但真正给我们的直观是，多了关于桶负载的“信息”——这也能某种程度上说明，每次挑选$d$个桶时，$d = 1$和$d = 2$有本质的区别（指数倍下降），而$d = 2$和$d = O(1)$没有本质的区别（常数倍下降）。 指数级的负载下降。那么，我的朋友，代价是什么呢？ $d = 1$与$d &amp;gt; 1$的区别是RTT，球需要发起一轮询问并接收一轮消息。信息的传递使得最终的负载有了指数级的下降。 四、进一步的结论 我们已经讨论了静态模型（逐个地扔球进桶）中扔$n$个球进$n$个桶的情况，每次随机挑两个桶的方法比起完全随机扔球会有指数级的最大负载下降。在本章中我们会介绍当球数远大于桶数时的结果，以及其他模型下的结论。 在本章的讨论中，我们记球数为$m$，记桶数为$n.$ 静态模型下随机扔$m » n$个球 在前两章的讨论中，为了分析的简便，我们都是假设$m = n$；证明也可以容易地扩展到$m = n\log n$的情况。但当球数多项式倍于桶数的时候，即$m = \textrm{poly}(n)$时，证明将变得复杂起来——而这恰恰是负载均衡话题中通常会讨论到的情况——请求数量远多于服务器的数量。 我们下面介绍Raab和Steger关于完全随机扔球进桶的工作和Berenbrink等人在STOC 2000的工作；Talwar和Wieder在ICALP 2014给出了与后者同样的结论但证明更简化的版本。 在我们的模型中，我们定义随机变量$Gap$为扔完$m$个球进$n$个桶后，负载最大的桶的球数与桶里球数的期望之差。例如，我们前两章讨论的$n = m$结果，对于完全随机扔球进桶，$E[Gap] = \Omega(\frac {\ln n } {\ln\ln n}) - 1 = \Omega(\frac {\ln n } {\ln\ln n})$；而随机挑两个桶扔进负载较小的桶里，我们有$E[Gap] = \Omega(\ln\ln n) - 1 = \Omega(\ln\ln n).$ Raab和Steger证明了，对于$m &amp;gt; \frac n {\textrm{polylog}(n)}$，完全随机扔球进桶的情况是以很高的概率： \[Gap = \Omega(\sqrt{\frac {m\log n}{n}}).\] 而Berenbrink等人证明了，对于任意的$m$，每次随机选$d&amp;gt;1$个桶并扔球进负载较低的桶里，有： \[E[Gap] \leq \frac {\log\log n}{\log d} + O(\log\log\log n).\] 注意，这里每次挑两个桶的$Gap$的期望与球数不再相关！即使$m = 2^n$，最后$Gap$的期望也仍然只有$O(\log\log n)$！ 动态模型 现在我们考虑这样的“超市模型”（supermarket model）——超市有$n$个收银台，每个收银台给顾客结账的时间服从均值为$1$的指数分布，顾客的到来服从参数为$\lambda n$的泊松过程（$0 &amp;lt; \lambda &amp;lt; 1$）（可以简单理解为任意两个顾客到达收银台的间隔的期望是$\frac 1 {\lambda n}$，即每单位时间收银台前会新增$\lambda n$个顾客），每个收银台遵循FIFO的规则为顾客结账。假设每个顾客抵达收银台时随机选择$d$个收银台，并前往其中负载最小的收银台排队等候。如图，顾客A选择随机选两条队列，然后排到其中长度较小的那一个中；顾客B刚被服务，已经离开收银台。 这一超市模型在某种程度上符合现实中的负载均衡情况。Michael Mitzenmacher在其博士论文中讨论了该情况，由于分析十分复杂，我们也仅介绍结论： 队列初始都为空的情况下，对于任意的$T &amp;gt; 0$，对于$d&amp;gt;2$，在时间段$[0, T]$中队伍长度的最大值以很高的概率为$\frac {\log\log n} {\log d} + O(1).$ 即，我们在动态模型中得到了静态模型类似的结论，只要该过程每时刻到达收银台的顾客数的期望不超过收银台的数量，那么任意时间段内队伍的最大长度都只会是$\Omega(\log\log n)$！ 甚至我们可以扩展：高优先级的请求（出现概率为$p$）随机挑两个服务器并进入负载较低的服务器排队，而低优先级的请求（出现概率为$1-p$）完全随机地挑选一个服务器；请求的出现仍然服从参数为$\lambda n$的泊松过程，在$\lambda = 0.99$时我们可以画出图像： 可以看见，只要有一小部分任务“选两个再多瞅一眼”，就能显著降低队列长度的期望。 总结 我们在这一系列的文章中介绍了概率的几个基本概念与基本不等式，并应用它们尝试解决扔$n$个球进$n$个桶游戏中最大负载的桶的球数的期望，我们发现：每次随机挑选两个桶并将球扔进负载较低的桶里，比起完全随机挑选一个桶再扔进去有了指数级的负载降低，即从$\Omega(\frac {\log n} {\log\log n})$降低到$O(\log\log n).$ 我们进一步介绍了当球数远多于桶数时，随机挑两个的结果使得最大负载与平均负载的差值（$Gap$）与球数不再相关，以及动态模型中随机挑两个的策略也可以得到和静态模型中相似的结果。 我们认为其背后的哲学在于，随机挑两个球的模型是因为其知道了桶里球分布的信息，使得最终结果有了指数级的提升。但其代价在于，信息的传递需要时间。在最后我们也介绍了，只有一部分球随机选两个的动态模型，最终的结果也能有很大的提升。 当然在现实中我们不期望负载均衡是完全符合我们的假设，例如请求的到来服从泊松分布、每台服务器的性能相同、每个请求的完成时间的期望相同，但是对于这样理论情况的分析还是可以一定程度上指导我们的算法。希望这一系列的文章对你有所帮助。 感谢阅读！ 参考文献 Mitzenmacher M, Upfal E. Probability and computing: Randomization and probabilistic techniques in algorithms and data analysis. Cambridge university press, 2017. Gupta A. Lec 8: Balls and Bins/Two Choices, Lecture Notes, 15-859M: Randomized Algorithms, Carnegie Mellon University. Mitzenmacher, Michael David. The power of two random choices in randomized load balancing. Diss. PhD thesis, Graduate Division of the University of California at Berkley, 1996. Berenbrink, Petra, et al. “Balanced allocations: the heavily loaded case.” Proceedings of the thirty-second annual ACM symposium on Theory of computing. 2000. Talwar, Kunal, and Udi Wieder. “Balanced allocations: A simple proof for the heavily loaded case.” International Colloquium on Automata, Languages, and Programming. Springer, Berlin, Heidelberg, 2014. Raab, Martin, and Angelika Steger. “Balls into bins”—A simple and tight analysis. International Workshop on Randomization and Approximation Techniques in Computer Science. Springer, Berlin, Heidelberg, 1998. Richa, Andrea W., M. Mitzenmacher, and R. Sitaraman. “The power of two random choices: A survey of techniques and results.” Combinatorial Optimization 9 (2001): 255-304. 存在$0\leq p_i \leq 1$使得$X_i$以$p_i$的概率使得$X_i = 1$，以$(1-p_i)$的概率使得$X_i = 0$。 &amp;#8617; 这里我们使用了$e^{\ln x} = x.$ &amp;#8617; 这里我们使用了$x^y = (e^{\ln x})^y.$ &amp;#8617;</summary></entry></feed>